{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-react-grid\n * Generated: 2019-03-28\n * Version: 1.10.5\n * License: https://js.devexpress.com/Licensing\n */\nimport { createElement, PureComponent, Fragment, createRef } from 'react';\nimport { Plugin, Getter, Template, TemplatePlaceholder, PluginHost, TemplateConnector, createStateHelper, Action, DragDropProvider as DragDropProvider$1, withComponents, DropTarget, DragSource, RefHolder, Sizer, connectProps } from '@devexpress/dx-react-core';\nimport { rowIdGetter, cellValueGetter, columnChooserItems, changeColumnFilter, getColumnExtensionValueGetter, filterExpression, defaultFilterPredicate, filteredCollapsedRowsGetter, unwrappedFilteredRows, filteredRows, getColumnExtension, startEditRows, stopEditRows, changeRow, cancelChanges, changedRowsByIds, addRow, changeAddedRow, cancelAddedRows, addedRowsByIds, deleteRows, cancelDeletedRows, createRowChangeGetter, setCurrentPage, setPageSize, rowsWithPageHeaders, rowCount, paginatedRows, currentPage, toggleExpandedGroups, draftColumnGrouping, cancelColumnGroupingDraft, adjustSortIndex, changeColumnGrouping, groupRowChecker, groupRowLevelKeyGetter, groupCollapsedRowsGetter, expandedGroupRows, groupedRows, customGroupingRowIdGetter, customGroupedRows, toggleSelection, rowsWithAvailableToSelect, allSelected, someSelected, unwrapSelectedRows, getPersistentSortedColumns, calculateKeepOther, changeColumnSorting, sortedRows, draftOrder, TABLE_DATA_TYPE, getTableTargetColumnIndex, changeColumnOrder, TABLE_REORDERING_TYPE, tableHeaderRowsWithReordering, orderedColumns, tableColumnsWithDataRows, tableCellColSpanGetter, isHeaderStubTableCell, isDataTableCell, isNoDataTableRow, isNoDataTableCell, isDataTableRow, TABLE_NODATA_TYPE, tableRowsWithDataRows, isSelectAllTableCell, isSelectTableCell, TABLE_SELECT_TYPE, tableColumnsWithSelection, toggleDetailRowExpanded, isDetailToggleTableCell, isDetailRowExpanded, isDetailTableRow, isDetailTableCell, TABLE_DETAIL_TYPE, tableDetailCellColSpanGetter, tableColumnsWithDetail, tableRowsWithExpandedDetail, isGroupTableRow, isGroupTableCell, isGroupIndentTableCell, TABLE_GROUP_TYPE, tableRowsWithGrouping, tableGroupCellColSpanGetter, tableColumnsWithGrouping, isHeadingTableCell, getColumnSortingDirection, isHeadingTableRow, TABLE_HEADING_TYPE, tableRowsWithHeading, isBandedOrHeaderRow, getBandComponent, BAND_DUPLICATE_RENDER, BAND_EMPTY_CELL, BAND_GROUP_CELL, BAND_HEADER_CELL, isBandedTableRow, TABLE_BAND_TYPE, tableRowsWithBands, tableHeaderColumnChainsWithBands, isFilterTableCell, getColumnFilterConfig, getColumnFilterOperations, getSelectedFilterOperation, isFilterTableRow, TABLE_FILTER_TYPE, tableHeaderRowsWithFilter, isFilterValueEmpty, isEditTableCell, isAddedTableRow, getRowChange, isEditTableRow, TABLE_ADDED_TYPE, TABLE_EDIT_TYPE, tableRowsWithEditing, isHeadingEditCommandsTableCell, isEditCommandsTableCell, TABLE_EDIT_COMMAND_TYPE, tableColumnsWithEditing, tableColumnsWithWidths, tableColumnsWithDraftWidths, changeTableColumnWidth, draftTableColumnWidth, cancelTableColumnWidthDraft, pageCount, getGroupCellTargetIndex, groupingPanelItems, getAvailableFilterOperationsGetter, toggleColumn, tableDataColumnsExist, visibleTableColumns, toggleRowExpanded, expandedTreeRows, customTreeRowIdGetter, customTreeRowLevelKeyGetter, isTreeRowLeafGetter, getTreeRowLevelGetter, collapsedTreeRowsGetter, unwrappedCustomTreeRows, customTreeRowsWithMeta, isTreeTableCell, changeSearchValue, searchFilterExpression, calculateFixedColumnProps, isFixedTableRow, tableHeaderRowsWithFixed, tableHeaderColumnChainsWithFixed, tableColumnsWithFixed, defaultSummaryCalculator, totalSummaryValues, groupSummaryValues, treeSummaryValues, isTotalSummaryTableCell, getColumnSummaries, isGroupSummaryTableCell, isTreeSummaryTableCell, isTotalSummaryTableRow, isGroupSummaryTableRow, isTreeSummaryTableRow, TABLE_TREE_SUMMARY_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_TOTAL_SUMMARY_TYPE, tableRowsWithSummaries, tableRowsWithTotalSummaries, getAnimations, TABLE_FLEX_TYPE, filterActiveAnimations, evalAnimations, getColumnWidthGetter, TABLE_STUB_TYPE, getCollapsedGrid } from '@devexpress/dx-grid-core';\nimport { getMessagesFormatter, memoize, isEdgeBrowser } from '@devexpress/dx-core';\nimport { findDOMNode } from 'react-dom';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n\nvar GridCore =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(GridCore, _super);\n\n  function GridCore() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GridCore.prototype.render = function () {\n    var _a = this.props,\n        rows = _a.rows,\n        columns = _a.columns,\n        getRowId = _a.getRowId,\n        getCellValue = _a.getCellValue,\n        Root = _a.rootComponent;\n    return createElement(Plugin, null, createElement(Getter, {\n      name: \"rows\",\n      value: rows\n    }), createElement(Getter, {\n      name: \"getRowId\",\n      value: rowIdGetter(getRowId, rows)\n    }), createElement(Getter, {\n      name: \"columns\",\n      value: columns\n    }), createElement(Getter, {\n      name: \"getCellValue\",\n      value: cellValueGetter(getCellValue, columns)\n    }), createElement(Template, {\n      name: \"root\"\n    }, createElement(Root, null, createElement(TemplatePlaceholder, {\n      name: \"header\"\n    }), createElement(TemplatePlaceholder, {\n      name: \"body\"\n    }), createElement(TemplatePlaceholder, {\n      name: \"footer\"\n    }))));\n  };\n\n  return GridCore;\n}(PureComponent);\n\nvar GridBase = function GridBase(_a) {\n  var rows = _a.rows,\n      columns = _a.columns,\n      getRowId = _a.getRowId,\n      getCellValue = _a.getCellValue,\n      rootComponent = _a.rootComponent,\n      children = _a.children;\n  return createElement(PluginHost, null, createElement(GridCore, {\n    rows: rows,\n    columns: columns,\n    getRowId: getRowId,\n    getCellValue: getCellValue,\n    rootComponent: rootComponent\n  }), children);\n};\n/***\r\n * The Grid is a root container component designed to process and display data specified via\r\n * the `rows` property. You can configure columns using the `columns` property. The Grid's\r\n * functionality  is implemented in several plugins specified as child components.\r\n * See the plugins concept for details.\r\n * */\n\n\nvar Grid = GridBase;\nvar pluginDependencies = [{\n  name: 'TableColumnVisibility'\n}, {\n  name: 'Toolbar'\n}];\n\nvar ColumnChooserBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ColumnChooserBase, _super);\n\n  function ColumnChooserBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      visible: false\n    };\n    _this.handleToggle = _this.handleToggle.bind(_this);\n    _this.handleHide = _this.handleHide.bind(_this);\n    _this.setButtonRef = _this.setButtonRef.bind(_this);\n    return _this;\n  }\n\n  ColumnChooserBase.prototype.setButtonRef = function (button) {\n    this.button = button;\n  };\n\n  ColumnChooserBase.prototype.handleToggle = function () {\n    var visible = this.state.visible;\n    this.setState({\n      visible: !visible\n    });\n  };\n\n  ColumnChooserBase.prototype.handleHide = function () {\n    this.setState({\n      visible: false\n    });\n  };\n\n  ColumnChooserBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        Overlay = _a.overlayComponent,\n        Container = _a.containerComponent,\n        Item = _a.itemComponent,\n        ToggleButton = _a.toggleButtonComponent,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(messages);\n    var visible = this.state.visible;\n    return createElement(Plugin, {\n      name: \"ColumnChooser\",\n      dependencies: pluginDependencies\n    }, createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a, _b) {\n      var columns = _a.columns,\n          hiddenColumnNames = _a.hiddenColumnNames,\n          isColumnTogglingEnabled = _a.isColumnTogglingEnabled;\n      var toggleColumnVisibility = _b.toggleColumnVisibility;\n      return createElement(Fragment, null, createElement(ToggleButton, {\n        buttonRef: _this.setButtonRef,\n        onToggle: _this.handleToggle,\n        getMessage: getMessage,\n        active: visible\n      }), createElement(Overlay, {\n        visible: visible,\n        target: _this.button,\n        onHide: _this.handleHide\n      }, createElement(Container, null, columnChooserItems(columns, hiddenColumnNames).map(function (item) {\n        var columnName = item.column.name;\n        var togglingEnabled = isColumnTogglingEnabled(columnName);\n        return createElement(Item, {\n          key: columnName,\n          item: item,\n          disabled: !togglingEnabled,\n          onToggle: function onToggle() {\n            return toggleColumnVisibility(columnName);\n          }\n        });\n      }))));\n    })));\n  };\n\n  ColumnChooserBase.defaultProps = {\n    messages: {}\n  };\n  ColumnChooserBase.components = {\n    overlayComponent: 'Overlay',\n    containerComponent: 'Container',\n    itemComponent: 'Item',\n    toggleButtonComponent: 'ToggleButton'\n  };\n  return ColumnChooserBase;\n}(PureComponent);\n/***\r\n * The ColumnChooser plugin allows a user to toggle grid columns' visibility at runtime.\r\n * The column chooser lists columns with checkboxes that control a corresponding\r\n * column's visibility.\r\n * */\n\n\nvar ColumnChooser = ColumnChooserBase;\n\nvar columnExtensionValueGetter = function columnExtensionValueGetter(columnExtensions, defaultValue) {\n  return getColumnExtensionValueGetter(columnExtensions, 'filteringEnabled', defaultValue);\n};\n\nvar filterExpressionComputed = function filterExpressionComputed(_a) {\n  var filters = _a.filters,\n      filterExpressionValue = _a.filterExpression;\n  return filterExpression(filters, filterExpressionValue);\n};\n\nvar FilteringStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(FilteringStateBase, _super);\n\n  function FilteringStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      filters: props.filters || props.defaultFilters\n    };\n    var stateHelper = createStateHelper(_this, {\n      filters: function filters() {\n        var onFiltersChange = _this.props.onFiltersChange;\n        return onFiltersChange;\n      }\n    });\n    _this.changeColumnFilter = stateHelper.applyFieldReducer.bind(stateHelper, 'filters', changeColumnFilter);\n    return _this;\n  } // tslint:disable-next-line:member-ordering\n\n\n  FilteringStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.filters,\n        filters = _a === void 0 ? prevState.filters : _a;\n    return {\n      filters: filters\n    };\n  };\n\n  FilteringStateBase.prototype.render = function () {\n    var filters = this.state.filters;\n    var _a = this.props,\n        columnExtensions = _a.columnExtensions,\n        columnFilteringEnabled = _a.columnFilteringEnabled;\n    return createElement(Plugin, {\n      name: \"FilteringState\"\n    }, createElement(Getter, {\n      name: \"filters\",\n      value: filters\n    }), createElement(Getter, {\n      name: \"filterExpression\",\n      computed: filterExpressionComputed\n    }), createElement(Getter, {\n      name: \"isColumnFilteringEnabled\",\n      value: columnExtensionValueGetter(columnExtensions, columnFilteringEnabled)\n    }), createElement(Action, {\n      name: \"changeColumnFilter\",\n      action: this.changeColumnFilter\n    }));\n  };\n\n  FilteringStateBase.defaultProps = {\n    defaultFilters: [],\n    columnFilteringEnabled: true\n  };\n  return FilteringStateBase;\n}(PureComponent);\n/** A plugin that manages the filtering state. */\n\n\nvar FilteringState = FilteringStateBase;\nvar pluginDependencies$1 = [{\n  name: 'FilteringState',\n  optional: true\n}, {\n  name: 'SearchState',\n  optional: true\n}];\n\nvar getCollapsedRowsComputed = function getCollapsedRowsComputed(_a) {\n  var rows = _a.rows;\n  return filteredCollapsedRowsGetter(rows);\n};\n\nvar unwrappedRowsComputed = function unwrappedRowsComputed(_a) {\n  var rows = _a.rows;\n  return unwrappedFilteredRows(rows);\n};\n\nvar IntegratedFilteringBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(IntegratedFilteringBase, _super);\n\n  function IntegratedFilteringBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IntegratedFilteringBase.prototype.render = function () {\n    var columnExtensions = this.props.columnExtensions;\n\n    var getColumnPredicate = function getColumnPredicate(columnName) {\n      return getColumnExtension(columnExtensions, columnName).predicate;\n    };\n\n    var rowsComputed = function rowsComputed(_a) {\n      var rows = _a.rows,\n          filterExpression = _a.filterExpression,\n          getCellValue = _a.getCellValue,\n          getRowLevelKey = _a.getRowLevelKey,\n          getCollapsedRows = _a.getCollapsedRows;\n      return filteredRows(rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows);\n    };\n\n    return createElement(Plugin, {\n      name: \"IntegratedFiltering\",\n      dependencies: pluginDependencies$1\n    }, createElement(Getter, {\n      name: \"rows\",\n      computed: rowsComputed\n    }), createElement(Getter, {\n      name: \"getCollapsedRows\",\n      computed: getCollapsedRowsComputed\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: unwrappedRowsComputed\n    }));\n  };\n\n  return IntegratedFilteringBase;\n}(PureComponent);\n\nIntegratedFilteringBase.defaultPredicate = defaultFilterPredicate;\nvar IntegratedFiltering = IntegratedFilteringBase;\n\nvar columnExtensionValueGetter$1 = function columnExtensionValueGetter$1(columnExtensions, defaultValue) {\n  return getColumnExtensionValueGetter(columnExtensions, 'editingEnabled', defaultValue);\n};\n\nvar EditingStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(EditingStateBase, _super);\n\n  function EditingStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    var rowChanges = props.rowChanges || props.defaultRowChanges;\n    var addedRows = props.addedRows || props.defaultAddedRows;\n\n    var getRowChanges = function getRowChanges() {\n      var stateRowChanges = _this.state.rowChanges;\n      return stateRowChanges;\n    };\n\n    var getAddedRows = function getAddedRows() {\n      var stateAddedRows = _this.state.addedRows;\n      return stateAddedRows;\n    };\n\n    _this.state = {\n      addedRows: addedRows,\n      rowChanges: rowChanges,\n      editingRowIds: props.editingRowIds || props.defaultEditingRowIds,\n      deletedRowIds: props.deletedRowIds || props.defaultDeletedRowIds\n    };\n    var stateHelper = createStateHelper(_this, {\n      editingRowIds: function editingRowIds() {\n        var onEditingRowIdsChange = _this.props.onEditingRowIdsChange;\n        return onEditingRowIdsChange;\n      },\n      addedRows: function addedRows() {\n        var onAddedRowsChange = _this.props.onAddedRowsChange;\n        return onAddedRowsChange;\n      },\n      rowChanges: function rowChanges() {\n        var onRowChangesChange = _this.props.onRowChangesChange;\n        return onRowChangesChange;\n      },\n      deletedRowIds: function deletedRowIds() {\n        var onDeletedRowIdsChange = _this.props.onDeletedRowIdsChange;\n        return onDeletedRowIdsChange;\n      }\n    });\n    _this.startEditRows = stateHelper.applyFieldReducer.bind(stateHelper, 'editingRowIds', startEditRows);\n    _this.stopEditRows = stateHelper.applyFieldReducer.bind(stateHelper, 'editingRowIds', stopEditRows);\n    _this.changeRow = stateHelper.applyFieldReducer.bind(stateHelper, 'rowChanges', changeRow);\n    _this.cancelChangedRows = stateHelper.applyFieldReducer.bind(stateHelper, 'rowChanges', cancelChanges);\n\n    _this.commitChangedRows = function (_a) {\n      var rowIds = _a.rowIds;\n      var onCommitChanges = _this.props.onCommitChanges;\n      onCommitChanges({\n        changed: changedRowsByIds(getRowChanges(), rowIds)\n      });\n\n      _this.cancelChangedRows({\n        rowIds: rowIds\n      });\n    };\n\n    _this.addRow = stateHelper.applyFieldReducer.bind(stateHelper, 'addedRows', addRow);\n    _this.changeAddedRow = stateHelper.applyFieldReducer.bind(stateHelper, 'addedRows', changeAddedRow);\n    _this.cancelAddedRows = stateHelper.applyFieldReducer.bind(stateHelper, 'addedRows', cancelAddedRows);\n\n    _this.commitAddedRows = function (_a) {\n      var rowIds = _a.rowIds;\n      var onCommitChanges = _this.props.onCommitChanges;\n      onCommitChanges({\n        added: addedRowsByIds(getAddedRows(), rowIds)\n      });\n\n      _this.cancelAddedRows({\n        rowIds: rowIds\n      });\n    };\n\n    _this.deleteRows = stateHelper.applyFieldReducer.bind(stateHelper, 'deletedRowIds', deleteRows);\n    _this.cancelDeletedRows = stateHelper.applyFieldReducer.bind(stateHelper, 'deletedRowIds', cancelDeletedRows);\n\n    _this.commitDeletedRows = function (_a) {\n      var rowIds = _a.rowIds;\n      var onCommitChanges = _this.props.onCommitChanges;\n      onCommitChanges({\n        deleted: rowIds\n      });\n\n      _this.cancelDeletedRows({\n        rowIds: rowIds\n      });\n    };\n\n    return _this;\n  }\n\n  EditingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.editingRowIds,\n        editingRowIds = _a === void 0 ? prevState.editingRowIds : _a,\n        _b = nextProps.rowChanges,\n        rowChanges = _b === void 0 ? prevState.rowChanges : _b,\n        _c = nextProps.addedRows,\n        addedRows = _c === void 0 ? prevState.addedRows : _c,\n        _d = nextProps.deletedRowIds,\n        deletedRowIds = _d === void 0 ? prevState.deletedRowIds : _d;\n    return {\n      editingRowIds: editingRowIds,\n      rowChanges: rowChanges,\n      addedRows: addedRows,\n      deletedRowIds: deletedRowIds\n    };\n  };\n\n  EditingStateBase.prototype.render = function () {\n    var _a = this.props,\n        createRowChange = _a.createRowChange,\n        columnExtensions = _a.columnExtensions,\n        columnEditingEnabled = _a.columnEditingEnabled;\n    var _b = this.state,\n        editingRowIds = _b.editingRowIds,\n        rowChanges = _b.rowChanges,\n        addedRows = _b.addedRows,\n        deletedRowIds = _b.deletedRowIds;\n    return createElement(Plugin, {\n      name: \"EditingState\"\n    }, createElement(Getter, {\n      name: \"createRowChange\",\n      value: createRowChangeGetter(createRowChange, columnExtensions)\n    }), createElement(Getter, {\n      name: \"editingRowIds\",\n      value: editingRowIds\n    }), createElement(Action, {\n      name: \"startEditRows\",\n      action: this.startEditRows\n    }), createElement(Action, {\n      name: \"stopEditRows\",\n      action: this.stopEditRows\n    }), createElement(Getter, {\n      name: \"rowChanges\",\n      value: rowChanges\n    }), createElement(Action, {\n      name: \"changeRow\",\n      action: this.changeRow\n    }), createElement(Action, {\n      name: \"cancelChangedRows\",\n      action: this.cancelChangedRows\n    }), createElement(Action, {\n      name: \"commitChangedRows\",\n      action: this.commitChangedRows\n    }), createElement(Getter, {\n      name: \"addedRows\",\n      value: addedRows\n    }), createElement(Action, {\n      name: \"addRow\",\n      action: this.addRow\n    }), createElement(Action, {\n      name: \"changeAddedRow\",\n      action: this.changeAddedRow\n    }), createElement(Action, {\n      name: \"cancelAddedRows\",\n      action: this.cancelAddedRows\n    }), createElement(Action, {\n      name: \"commitAddedRows\",\n      action: this.commitAddedRows\n    }), createElement(Getter, {\n      name: \"deletedRowIds\",\n      value: deletedRowIds\n    }), createElement(Action, {\n      name: \"deleteRows\",\n      action: this.deleteRows\n    }), createElement(Action, {\n      name: \"cancelDeletedRows\",\n      action: this.cancelDeletedRows\n    }), createElement(Action, {\n      name: \"commitDeletedRows\",\n      action: this.commitDeletedRows\n    }), createElement(Getter, {\n      name: \"isColumnEditingEnabled\",\n      value: columnExtensionValueGetter$1(columnExtensions, columnEditingEnabled)\n    }));\n  };\n\n  EditingStateBase.defaultProps = {\n    columnEditingEnabled: true,\n    defaultEditingRowIds: [],\n    defaultRowChanges: {},\n    defaultAddedRows: [],\n    defaultDeletedRowIds: []\n  };\n  return EditingStateBase;\n}(PureComponent);\n/***\r\n * A plugin that manages grid rows' editing state. It arranges grid rows\r\n * by different lists depending on a row's state.\r\n * */\n\n\nvar EditingState = EditingStateBase;\n\nvar PagingStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PagingStateBase, _super);\n\n  function PagingStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      currentPage: props.currentPage || props.defaultCurrentPage,\n      pageSize: props.pageSize !== undefined ? props.pageSize : props.defaultPageSize\n    };\n    var stateHelper = createStateHelper(_this, {\n      currentPage: function currentPage() {\n        var onCurrentPageChange = _this.props.onCurrentPageChange;\n        return onCurrentPageChange;\n      },\n      pageSize: function pageSize() {\n        var onPageSizeChange = _this.props.onPageSizeChange;\n        return onPageSizeChange;\n      }\n    });\n    _this.setCurrentPage = stateHelper.applyFieldReducer.bind(stateHelper, 'currentPage', setCurrentPage);\n    _this.setPageSize = stateHelper.applyFieldReducer.bind(stateHelper, 'pageSize', setPageSize);\n    return _this;\n  }\n\n  PagingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.currentPage,\n        currentPage = _a === void 0 ? prevState.currentPage : _a,\n        _b = nextProps.pageSize,\n        pageSize = _b === void 0 ? prevState.pageSize : _b;\n    return {\n      currentPage: currentPage,\n      pageSize: pageSize\n    };\n  };\n\n  PagingStateBase.prototype.render = function () {\n    var _a = this.state,\n        pageSize = _a.pageSize,\n        currentPage = _a.currentPage;\n    return createElement(Plugin, {\n      name: \"PagingState\"\n    }, createElement(Getter, {\n      name: \"currentPage\",\n      value: currentPage\n    }), createElement(Getter, {\n      name: \"pageSize\",\n      value: pageSize\n    }), createElement(Action, {\n      name: \"setCurrentPage\",\n      action: this.setCurrentPage\n    }), createElement(Action, {\n      name: \"setPageSize\",\n      action: this.setPageSize\n    }));\n  };\n\n  PagingStateBase.defaultProps = {\n    defaultPageSize: 10,\n    defaultCurrentPage: 0\n  };\n  return PagingStateBase;\n}(PureComponent);\n/***\r\n * A plugin that manages the paging state. It controls the total page count depending on the\r\n * total row count and the specified page size, controls the currently selected page number\r\n * and changes it in response to the corresponding actions.\r\n * */\n\n\nvar PagingState = PagingStateBase;\nvar pluginDependencies$2 = [{\n  name: 'PagingState'\n}];\n\nvar rowsWithHeadersComputed = function rowsWithHeadersComputed(_a) {\n  var rows = _a.rows,\n      pageSize = _a.pageSize,\n      getRowLevelKey = _a.getRowLevelKey;\n  return rowsWithPageHeaders(rows, pageSize, getRowLevelKey);\n};\n\nvar totalCountComputed = function totalCountComputed(_a) {\n  var rows = _a.rows;\n  return rowCount(rows);\n};\n\nvar paginatedRowsComputed = function paginatedRowsComputed(_a) {\n  var rows = _a.rows,\n      pageSize = _a.pageSize,\n      page = _a.currentPage;\n  return paginatedRows(rows, pageSize, page);\n};\n\nvar currentPageComputed = function currentPageComputed(_a, _b) {\n  var page = _a.currentPage,\n      totalCount = _a.totalCount,\n      pageSize = _a.pageSize;\n  var setCurrentPage = _b.setCurrentPage;\n  return currentPage(page, totalCount, pageSize, setCurrentPage);\n}; // eslint-disable-next-line react/prefer-stateless-function\n\n\nvar IntegratedPagingBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(IntegratedPagingBase, _super);\n\n  function IntegratedPagingBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IntegratedPagingBase.prototype.render = function () {\n    return createElement(Plugin, {\n      name: \"IntegratedPaging\",\n      dependencies: pluginDependencies$2\n    }, createElement(Getter, {\n      name: \"rows\",\n      computed: rowsWithHeadersComputed\n    }), createElement(Getter, {\n      name: \"totalCount\",\n      computed: totalCountComputed\n    }), createElement(Getter, {\n      name: \"currentPage\",\n      computed: currentPageComputed\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: paginatedRowsComputed\n    }));\n  };\n\n  return IntegratedPagingBase;\n}(PureComponent);\n/***\r\n * A plugin that performs built-in data paging. It also changes the current page if the provided\r\n * one cannot be applied due to fewer available pages.\r\n * */\n\n\nvar IntegratedPaging = IntegratedPagingBase;\nvar pluginDependencies$3 = [{\n  name: 'PagingState'\n}];\n\nvar CustomPagingBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(CustomPagingBase, _super);\n\n  function CustomPagingBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CustomPagingBase.prototype.render = function () {\n    var totalCount = this.props.totalCount;\n    return createElement(Plugin, {\n      name: \"CustomPaging\",\n      dependencies: pluginDependencies$3\n    }, createElement(Getter, {\n      name: \"totalCount\",\n      value: totalCount\n    }));\n  };\n\n  CustomPagingBase.defaultProps = {\n    totalCount: 0\n  };\n  return CustomPagingBase;\n}(PureComponent);\n/** A plugin that allows implementing a custom totalCount calculation logic. */\n\n\nvar CustomPaging = CustomPagingBase;\nvar dependencies = [{\n  name: 'SortingState',\n  optional: true\n}];\n\nvar columnExtensionValueGetter$2 = function columnExtensionValueGetter$2(columnExtensions, defaultValue) {\n  return getColumnExtensionValueGetter(columnExtensions, 'groupingEnabled', defaultValue);\n};\n\nvar GroupingStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(GroupingStateBase, _super);\n\n  function GroupingStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      grouping: props.grouping || props.defaultGrouping,\n      draftGrouping: null,\n      expandedGroups: props.expandedGroups || props.defaultExpandedGroups\n    };\n    _this.stateHelper = createStateHelper(_this, {\n      grouping: function grouping() {\n        var onGroupingChange = _this.props.onGroupingChange;\n        return onGroupingChange;\n      },\n      expandedGroups: function expandedGroups() {\n        var onExpandedGroupsChange = _this.props.onExpandedGroupsChange;\n        return onExpandedGroupsChange;\n      }\n    });\n    _this.changeColumnGrouping = _this.changeColumnGrouping.bind(_this);\n    _this.toggleGroupExpanded = _this.stateHelper.applyReducer.bind(_this.stateHelper, toggleExpandedGroups);\n    _this.draftColumnGrouping = _this.stateHelper.applyReducer.bind(_this.stateHelper, draftColumnGrouping);\n    _this.cancelColumnGroupingDraft = _this.stateHelper.applyReducer.bind(_this.stateHelper, cancelColumnGroupingDraft);\n    _this.changeColumnSorting = _this.changeColumnSorting.bind(_this);\n    return _this;\n  }\n\n  GroupingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.grouping,\n        grouping = _a === void 0 ? prevState.grouping : _a,\n        _b = nextProps.expandedGroups,\n        expandedGroups = _b === void 0 ? prevState.expandedGroups : _b;\n    return {\n      grouping: grouping,\n      expandedGroups: expandedGroups\n    };\n  };\n\n  GroupingStateBase.prototype.changeColumnSorting = function (_a, _b, _c) {\n    var sorting = _b.sorting;\n    var changeColumnSorting = _c.changeColumnSorting;\n\n    var columnName = _a.columnName,\n        keepOther = _a.keepOther,\n        restParams = __rest(_a, [\"columnName\", \"keepOther\"]);\n\n    var grouping = this.state.grouping;\n    var groupingIndex = grouping.findIndex(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    });\n\n    if (groupingIndex === -1) {\n      changeColumnSorting(_assign({\n        columnName: columnName,\n        keepOther: keepOther || grouping.map(function (columnGrouping) {\n          return columnGrouping.columnName;\n        })\n      }, restParams));\n      return false;\n    }\n\n    var sortIndex = adjustSortIndex(groupingIndex, grouping, sorting);\n    changeColumnSorting(_assign({\n      columnName: columnName,\n      sortIndex: sortIndex,\n      keepOther: true\n    }, restParams));\n    return false;\n  };\n\n  GroupingStateBase.prototype.changeColumnGrouping = function (_a, getters, actions) {\n    var columnName = _a.columnName,\n        groupIndex = _a.groupIndex;\n    this.stateHelper.applyReducer(changeColumnGrouping, {\n      columnName: columnName,\n      groupIndex: groupIndex\n    }, function (nextState, state) {\n      var grouping = nextState.grouping;\n      var prevGrouping = state.grouping;\n      var sorting = getters.sorting;\n      var changeColumnSorting = actions.changeColumnSorting;\n      if (!sorting) return;\n      var columnSortingIndex = sorting.findIndex(function (columnSorting) {\n        return columnSorting.columnName === columnName;\n      });\n      var prevGroupingIndex = prevGrouping.findIndex(function (columnGrouping) {\n        return columnGrouping.columnName === columnName;\n      });\n      var groupingIndex = grouping.findIndex(function (columnGrouping) {\n        return columnGrouping.columnName === columnName;\n      });\n      if (columnSortingIndex === -1 || prevGroupingIndex === prevGrouping.length - 1 && groupingIndex === -1) return;\n      var sortIndex = adjustSortIndex(groupingIndex === -1 ? grouping.length : groupingIndex, grouping, sorting);\n      if (columnSortingIndex === sortIndex) return;\n      changeColumnSorting(_assign({\n        sortIndex: sortIndex,\n        keepOther: true\n      }, sorting[columnSortingIndex]));\n    });\n  };\n\n  GroupingStateBase.prototype.render = function () {\n    var _a = this.state,\n        grouping = _a.grouping,\n        draftGrouping = _a.draftGrouping,\n        expandedGroups = _a.expandedGroups;\n    var _b = this.props,\n        columnExtensions = _b.columnExtensions,\n        columnGroupingEnabled = _b.columnGroupingEnabled;\n    return createElement(Plugin, {\n      name: \"GroupingState\",\n      dependencies: dependencies\n    }, createElement(Getter, {\n      name: \"grouping\",\n      value: grouping\n    }), createElement(Getter, {\n      name: \"draftGrouping\",\n      value: draftGrouping || grouping\n    }), createElement(Getter, {\n      name: \"isColumnGroupingEnabled\",\n      value: columnExtensionValueGetter$2(columnExtensions, columnGroupingEnabled)\n    }), createElement(Action, {\n      name: \"changeColumnGrouping\",\n      action: this.changeColumnGrouping\n    }), createElement(Action, {\n      name: \"draftColumnGrouping\",\n      action: this.draftColumnGrouping\n    }), createElement(Action, {\n      name: \"cancelColumnGroupingDraft\",\n      action: this.cancelColumnGroupingDraft\n    }), createElement(Getter, {\n      name: \"expandedGroups\",\n      value: expandedGroups\n    }), createElement(Action, {\n      name: \"toggleGroupExpanded\",\n      action: this.toggleGroupExpanded\n    }), createElement(Action, {\n      name: \"changeColumnSorting\",\n      action: this.changeColumnSorting\n    }));\n  };\n\n  GroupingStateBase.defaultProps = {\n    defaultGrouping: [],\n    defaultExpandedGroups: [],\n    columnGroupingEnabled: true\n  };\n  return GroupingStateBase;\n}(PureComponent);\n/***\r\n * A plugin that manages the grouping state. It lists columns used for grouping and stores\r\n * information about expanded/collapsed groups.\r\n * */\n\n\nvar GroupingState = GroupingStateBase;\nvar pluginDependencies$4 = [{\n  name: 'GroupingState'\n}];\n\nvar getCollapsedRowsComputed$1 = function getCollapsedRowsComputed$1(_a) {\n  var getCollapsedRows = _a.getCollapsedRows;\n  return groupCollapsedRowsGetter(getCollapsedRows);\n};\n\nvar expandedGroupedRowsComputed = function expandedGroupedRowsComputed(_a) {\n  var rows = _a.rows,\n      grouping = _a.grouping,\n      expandedGroups = _a.expandedGroups;\n  return expandedGroupRows(rows, grouping, expandedGroups);\n};\n\nvar IntegratedGroupingBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(IntegratedGroupingBase, _super);\n\n  function IntegratedGroupingBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IntegratedGroupingBase.prototype.render = function () {\n    var columnExtensions = this.props.columnExtensions;\n\n    var getColumnCriteria = function getColumnCriteria(columnName) {\n      return getColumnExtension(columnExtensions, columnName).criteria;\n    };\n\n    var groupedRowsComputed = function groupedRowsComputed(_a) {\n      var rows = _a.rows,\n          grouping = _a.grouping,\n          getCellValue = _a.getCellValue;\n      return groupedRows(rows, grouping, getCellValue, getColumnCriteria);\n    };\n\n    return createElement(Plugin, {\n      name: \"IntegratedGrouping\",\n      dependencies: pluginDependencies$4\n    }, createElement(Getter, {\n      name: \"isGroupRow\",\n      value: groupRowChecker\n    }), createElement(Getter, {\n      name: \"getRowLevelKey\",\n      value: groupRowLevelKeyGetter\n    }), createElement(Getter, {\n      name: \"getCollapsedRows\",\n      computed: getCollapsedRowsComputed$1\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: groupedRowsComputed\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: expandedGroupedRowsComputed\n    }));\n  };\n\n  return IntegratedGroupingBase;\n}(PureComponent);\n/* tslint:disable: max-line-length */\n\n/** A plugin that performs built-in grouping and group expanding/collapsing. */\n\n\nvar IntegratedGrouping = IntegratedGroupingBase;\n/* tslint:enable: max-line-length */\n\nvar pluginDependencies$5 = [{\n  name: 'GroupingState'\n}];\n\nvar getCollapsedRowsComputed$2 = function getCollapsedRowsComputed$2(_a) {\n  var getCollapsedRows = _a.getCollapsedRows;\n  return groupCollapsedRowsGetter(getCollapsedRows);\n};\n\nvar expandedGroupedRowsComputed$1 = function expandedGroupedRowsComputed$1(_a) {\n  var rows = _a.rows,\n      grouping = _a.grouping,\n      expandedGroups = _a.expandedGroups;\n  return expandedGroupRows(rows, grouping, expandedGroups);\n};\n\nvar getRowIdComputed = function getRowIdComputed(_a) {\n  var getRowId = _a.getRowId,\n      rows = _a.rows;\n  return customGroupingRowIdGetter(getRowId, rows);\n};\n\nvar CustomGroupingBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(CustomGroupingBase, _super);\n\n  function CustomGroupingBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CustomGroupingBase.prototype.render = function () {\n    var _a = this.props,\n        getChildGroups = _a.getChildGroups,\n        appliedGrouping = _a.grouping,\n        appliedExpandedGroups = _a.expandedGroups;\n\n    var groupedRowsComputed = function groupedRowsComputed(_a) {\n      var rows = _a.rows,\n          grouping = _a.grouping;\n      return customGroupedRows(rows, grouping, getChildGroups);\n    };\n\n    return createElement(Plugin, {\n      name: \"CustomGrouping\",\n      dependencies: pluginDependencies$5\n    }, appliedGrouping && createElement(Getter, {\n      name: \"grouping\",\n      value: appliedGrouping\n    }), appliedExpandedGroups && createElement(Getter, {\n      name: \"expandedGroups\",\n      value: appliedExpandedGroups\n    }), createElement(Getter, {\n      name: \"isGroupRow\",\n      value: groupRowChecker\n    }), createElement(Getter, {\n      name: \"getRowLevelKey\",\n      value: groupRowLevelKeyGetter\n    }), createElement(Getter, {\n      name: \"getCollapsedRows\",\n      computed: getCollapsedRowsComputed$2\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: groupedRowsComputed\n    }), createElement(Getter, {\n      name: \"getRowId\",\n      computed: getRowIdComputed\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: expandedGroupedRowsComputed$1\n    }));\n  };\n\n  return CustomGroupingBase;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n/** A plugin that converts custom formatted grouped data to a supported format and performs local group expanding/collapsing. */\n\n\nvar CustomGrouping = CustomGroupingBase;\n\nvar SelectionStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SelectionStateBase, _super);\n\n  function SelectionStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      selection: props.selection || props.defaultSelection\n    };\n    var stateHelper = createStateHelper(_this, {\n      selection: function selection() {\n        var onSelectionChange = _this.props.onSelectionChange;\n        return onSelectionChange;\n      }\n    });\n    _this.toggleSelection = stateHelper.applyFieldReducer.bind(stateHelper, 'selection', toggleSelection);\n    return _this;\n  }\n\n  SelectionStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.selection,\n        selection = _a === void 0 ? prevState.selection : _a;\n    return {\n      selection: selection\n    };\n  };\n\n  SelectionStateBase.prototype.render = function () {\n    var selection = this.state.selection;\n    return createElement(Plugin, {\n      name: \"SelectionState\"\n    }, createElement(Getter, {\n      name: \"selection\",\n      value: selection\n    }), createElement(Action, {\n      name: \"toggleSelection\",\n      action: this.toggleSelection\n    }));\n  };\n\n  SelectionStateBase.defaultProps = {\n    defaultSelection: []\n  };\n  return SelectionStateBase;\n}(PureComponent);\n/** A plugin that manages the selection state. */\n\n\nvar SelectionState = SelectionStateBase;\n\nvar rowsWithAvailableToSelectComputed = function rowsWithAvailableToSelectComputed(_a) {\n  var rows = _a.rows,\n      getRowId = _a.getRowId,\n      isGroupRow = _a.isGroupRow;\n  return rowsWithAvailableToSelect(rows, getRowId, isGroupRow);\n};\n\nvar allSelectedComputed = function allSelectedComputed(_a) {\n  var rows = _a.rows,\n      selection = _a.selection;\n  return allSelected(rows, selection);\n};\n\nvar someSelectedComputed = function someSelectedComputed(_a) {\n  var rows = _a.rows,\n      selection = _a.selection;\n  return someSelected(rows, selection);\n};\n\nvar selectAllAvailableComputed = function selectAllAvailableComputed(_a) {\n  var availableToSelect = _a.rows.availableToSelect;\n  return !!availableToSelect.length;\n};\n\nvar toggleSelectAll = function toggleSelectAll(state, _a, _b) {\n  var availableToSelect = _a.rows.availableToSelect;\n  var toggleSelection = _b.toggleSelection;\n  toggleSelection({\n    state: state,\n    rowIds: availableToSelect\n  });\n};\n\nvar unwrapRowsComputed = function unwrapRowsComputed(_a) {\n  var rows = _a.rows;\n  return unwrapSelectedRows(rows);\n};\n\nvar pluginDependencies$6 = [{\n  name: 'SelectionState'\n}]; // eslint-disable-next-line react/prefer-stateless-function\n\nvar IntegratedSelectionBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(IntegratedSelectionBase, _super);\n\n  function IntegratedSelectionBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IntegratedSelectionBase.prototype.render = function () {\n    return createElement(Plugin, {\n      name: \"IntegratedSelection\",\n      dependencies: pluginDependencies$6\n    }, createElement(Getter, {\n      name: \"rows\",\n      computed: rowsWithAvailableToSelectComputed\n    }), createElement(Getter, {\n      name: \"allSelected\",\n      computed: allSelectedComputed\n    }), createElement(Getter, {\n      name: \"someSelected\",\n      computed: someSelectedComputed\n    }), createElement(Getter, {\n      name: \"selectAllAvailable\",\n      computed: selectAllAvailableComputed\n    }), createElement(Action, {\n      name: \"toggleSelectAll\",\n      action: toggleSelectAll\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: unwrapRowsComputed\n    }));\n  };\n\n  return IntegratedSelectionBase;\n}(PureComponent);\n/* tslint:disable: max-line-length */\n\n/** A plugin that performs built-in selection. */\n\n\nvar IntegratedSelection = IntegratedSelectionBase;\n/* tslint:enable: max-line-length */\n\nvar columnExtensionValueGetter$3 = function columnExtensionValueGetter$3(columnExtensions, defaultValue) {\n  return getColumnExtensionValueGetter(columnExtensions, 'sortingEnabled', defaultValue);\n};\n\nvar SortingStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SortingStateBase, _super);\n\n  function SortingStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      sorting: props.sorting || props.defaultSorting\n    };\n    var stateHelper = createStateHelper(_this, {\n      sorting: function sorting() {\n        var onSortingChange = _this.props.onSortingChange;\n        return onSortingChange;\n      }\n    });\n    _this.changeColumnSorting = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {\n      var _a = _this.props.sorting,\n          sorting = _a === void 0 ? prevState.sorting : _a;\n      var persistentSortedColumns = getPersistentSortedColumns(sorting, props.columnExtensions);\n      var keepOther = calculateKeepOther(prevState.sorting, payload.keepOther, persistentSortedColumns);\n      return changeColumnSorting(prevState, _assign({}, payload, {\n        keepOther: keepOther\n      }));\n    });\n    return _this;\n  }\n\n  SortingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.sorting,\n        sorting = _a === void 0 ? prevState.sorting : _a;\n    return {\n      sorting: sorting\n    };\n  };\n\n  SortingStateBase.prototype.render = function () {\n    var sorting = this.state.sorting;\n    var _a = this.props,\n        columnExtensions = _a.columnExtensions,\n        columnSortingEnabled = _a.columnSortingEnabled;\n    return createElement(Plugin, {\n      name: \"SortingState\"\n    }, createElement(Getter, {\n      name: \"sorting\",\n      value: sorting\n    }), createElement(Getter, {\n      name: \"isColumnSortingEnabled\",\n      value: columnExtensionValueGetter$3(columnExtensions, columnSortingEnabled)\n    }), createElement(Action, {\n      name: \"changeColumnSorting\",\n      action: this.changeColumnSorting\n    }));\n  };\n\n  SortingStateBase.defaultProps = {\n    defaultSorting: [],\n    columnSortingEnabled: true\n  };\n  return SortingStateBase;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n/** A plugin that manages the sorting state. It controls the list of columns that participate in sorting. */\n\n\nvar SortingState = SortingStateBase;\nvar pluginDependencies$7 = [{\n  name: 'SortingState'\n}];\n\nvar IntegratedSortingBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(IntegratedSortingBase, _super);\n\n  function IntegratedSortingBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IntegratedSortingBase.prototype.render = function () {\n    var columnExtensions = this.props.columnExtensions;\n\n    var getColumnCompare = function getColumnCompare(columnName) {\n      return getColumnExtension(columnExtensions, columnName).compare;\n    };\n\n    var rowsComputed = function rowsComputed(_a) {\n      var rows = _a.rows,\n          sorting = _a.sorting,\n          getCellValue = _a.getCellValue,\n          isGroupRow = _a.isGroupRow,\n          getRowLevelKey = _a.getRowLevelKey;\n      return sortedRows(rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey);\n    };\n\n    return createElement(Plugin, {\n      name: \"IntegratedSorting\",\n      dependencies: pluginDependencies$7\n    }, createElement(Getter, {\n      name: \"rows\",\n      computed: rowsComputed\n    }));\n  };\n\n  return IntegratedSortingBase;\n}(PureComponent);\n/** A plugin that performs built-in data sorting. */\n\n\nvar IntegratedSorting = IntegratedSortingBase;\n\nvar getTargetColumns = function getTargetColumns(payload, columns) {\n  return payload.filter(function (item) {\n    return item.type === 'column';\n  }).map(function (item) {\n    return columns.find(function (column) {\n      return column.name === item.columnName;\n    });\n  });\n}; // tslint:disable-next-line: max-line-length\n\n\nvar DragDropProviderBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DragDropProviderBase, _super);\n\n  function DragDropProviderBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      payload: null,\n      clientOffset: null\n    };\n\n    _this.change = function (_a) {\n      var payload = _a.payload,\n          clientOffset = _a.clientOffset;\n      return _this.setState({\n        payload: payload,\n        clientOffset: clientOffset\n      });\n    };\n\n    return _this;\n  }\n\n  DragDropProviderBase.prototype.render = function () {\n    var _a = this.props,\n        Container = _a.containerComponent,\n        Column = _a.columnComponent;\n    var _b = this.state,\n        payload = _b.payload,\n        clientOffset = _b.clientOffset;\n    return createElement(Plugin, {\n      name: \"DragDropProvider\"\n    }, createElement(Getter, {\n      name: \"draggingEnabled\",\n      value: true\n    }), createElement(Template, {\n      name: \"root\"\n    }, createElement(DragDropProvider$1, {\n      onChange: this.change\n    }, createElement(TemplatePlaceholder, null)), payload && createElement(TemplateConnector, null, function (_a) {\n      var columns = _a.columns;\n      return createElement(Container, {\n        clientOffset: clientOffset\n      }, getTargetColumns(payload, columns).map(function (column) {\n        return createElement(Column, {\n          key: column.name,\n          column: column\n        });\n      }));\n    })));\n  };\n\n  DragDropProviderBase.components = {\n    containerComponent: 'Container',\n    columnComponent: 'Column'\n  };\n  return DragDropProviderBase;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n/** A plugin that implements the drag-and-drop functionality and visualizes columns that are being dragged. */\n\n\nvar DragDropProvider = DragDropProviderBase;\nvar pluginDependencies$8 = [{\n  name: 'Table'\n}, {\n  name: 'DragDropProvider',\n  optional: true\n}];\n\nvar tableHeaderRowsComputed = function tableHeaderRowsComputed(_a) {\n  var tableHeaderRows = _a.tableHeaderRows;\n  return tableHeaderRowsWithReordering(tableHeaderRows);\n}; // tslint:disable-next-line: max-line-length\n\n\nvar TableColumnReorderingRaw =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableColumnReorderingRaw, _super);\n\n  function TableColumnReorderingRaw(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.cellDimensionGetters = {};\n    _this.cellDimensions = [];\n    _this.state = {\n      order: props.defaultOrder,\n      sourceColumnIndex: -1,\n      targetColumnIndex: -1\n    };\n    _this.onOver = _this.handleOver.bind(_this);\n    _this.onLeave = _this.handleLeave.bind(_this);\n    _this.onDrop = _this.handleDrop.bind(_this);\n    return _this;\n  }\n\n  TableColumnReorderingRaw.prototype.getState = function () {\n    var orderState = this.state.order;\n    var _a = this.props.order,\n        order = _a === void 0 ? orderState : _a;\n    return _assign({}, this.state, {\n      order: order\n    });\n  };\n\n  TableColumnReorderingRaw.prototype.getDraftOrder = function () {\n    var _a = this.getState(),\n        order = _a.order,\n        sourceColumnIndex = _a.sourceColumnIndex,\n        targetColumnIndex = _a.targetColumnIndex;\n\n    return draftOrder(order, sourceColumnIndex, targetColumnIndex);\n  };\n\n  TableColumnReorderingRaw.prototype.getAvailableColumns = function () {\n    var _this = this;\n\n    return this.getDraftOrder().filter(function (columnName) {\n      return !!_this.cellDimensionGetters[columnName];\n    });\n  };\n\n  TableColumnReorderingRaw.prototype.cacheCellDimensions = function () {\n    var _this = this;\n\n    this.cellDimensions = this.cellDimensions && this.cellDimensions.length ? this.cellDimensions : this.getAvailableColumns().map(function (columnName) {\n      return _this.cellDimensionGetters[columnName]();\n    });\n  };\n\n  TableColumnReorderingRaw.prototype.resetCellDimensions = function () {\n    this.cellDimensions = [];\n  };\n\n  TableColumnReorderingRaw.prototype.ensureCellDimensionGetters = function (tableColumns) {\n    var _this = this;\n\n    Object.keys(this.cellDimensionGetters).forEach(function (columnName) {\n      var columnIndex = tableColumns.findIndex(function (_a) {\n        var type = _a.type,\n            column = _a.column;\n        return type === TABLE_DATA_TYPE && column.name === columnName;\n      });\n\n      if (columnIndex === -1) {\n        delete _this.cellDimensionGetters[columnName];\n      }\n    });\n  }; // tslint:disable-next-line: max-line-length\n\n\n  TableColumnReorderingRaw.prototype.storeCellDimensionsGetter = function (tableColumn, getter, tableColumns) {\n    if (tableColumn.type === TABLE_DATA_TYPE) {\n      this.cellDimensionGetters[tableColumn.column.name] = getter;\n    }\n\n    this.ensureCellDimensionGetters(tableColumns);\n  };\n\n  TableColumnReorderingRaw.prototype.handleOver = function (_a) {\n    var payload = _a.payload,\n        x = _a.clientOffset.x;\n    var sourceColumnName = payload[0].columnName;\n    var availableColumns = this.getAvailableColumns();\n    var relativeSourceColumnIndex = availableColumns.indexOf(sourceColumnName);\n    if (relativeSourceColumnIndex === -1) return;\n    this.cacheCellDimensions();\n    var cellDimensions = this.cellDimensions;\n    var overlappedColumns = cellDimensions.filter(function (_a) {\n      var left = _a.left,\n          right = _a.right;\n      return left <= x && x <= right;\n    });\n    if (overlappedColumns.length > 1) return;\n    var relativeTargetIndex = getTableTargetColumnIndex(cellDimensions, relativeSourceColumnIndex, x);\n    if (relativeTargetIndex === -1) return;\n\n    var _b = this.getState(),\n        prevSourceColumnIndex = _b.sourceColumnIndex,\n        prevTargetColumnIndex = _b.targetColumnIndex;\n\n    var draftOrder = this.getDraftOrder();\n    var targetColumnIndex = draftOrder.indexOf(availableColumns[relativeTargetIndex]);\n    if (targetColumnIndex === prevTargetColumnIndex) return;\n    var sourceColumnIndex = prevSourceColumnIndex === -1 ? draftOrder.indexOf(sourceColumnName) : prevSourceColumnIndex;\n    this.setState({\n      sourceColumnIndex: sourceColumnIndex,\n      targetColumnIndex: targetColumnIndex\n    });\n  };\n\n  TableColumnReorderingRaw.prototype.handleLeave = function () {\n    this.setState({\n      sourceColumnIndex: -1,\n      targetColumnIndex: -1\n    });\n    this.resetCellDimensions();\n  };\n\n  TableColumnReorderingRaw.prototype.handleDrop = function () {\n    var _a = this.getState(),\n        sourceColumnIndex = _a.sourceColumnIndex,\n        targetColumnIndex = _a.targetColumnIndex,\n        order = _a.order;\n\n    var onOrderChange = this.props.onOrderChange;\n    if (sourceColumnIndex === -1 && targetColumnIndex === -1) return;\n    var nextOrder = changeColumnOrder(order, {\n      sourceColumnName: order[sourceColumnIndex],\n      targetColumnName: order[targetColumnIndex]\n    });\n    this.setState({\n      order: nextOrder,\n      sourceColumnIndex: -1,\n      targetColumnIndex: -1\n    });\n\n    if (onOrderChange) {\n      onOrderChange(nextOrder);\n    }\n\n    this.resetCellDimensions();\n  };\n\n  TableColumnReorderingRaw.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        Container = _a.tableContainerComponent,\n        Row = _a.rowComponent,\n        Cell = _a.cellComponent;\n\n    var columnsComputed = function columnsComputed(_a) {\n      var tableColumns = _a.tableColumns;\n      return orderedColumns(tableColumns, _this.getDraftOrder());\n    };\n\n    this.cellDimensionGetters = {};\n    return createElement(Plugin, {\n      name: \"TableColumnReordering\",\n      dependencies: pluginDependencies$8\n    }, createElement(Getter, {\n      name: \"tableColumns\",\n      computed: columnsComputed\n    }), createElement(Getter, {\n      name: \"tableHeaderRows\",\n      computed: tableHeaderRowsComputed\n    }), createElement(Template, {\n      name: \"table\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var draggingEnabled = _a.draggingEnabled;\n        return createElement(Container, _assign({}, params, {\n          onOver: _this.onOver,\n          onLeave: _this.onLeave,\n          onDrop: _this.onDrop,\n          draggingEnabled: draggingEnabled\n        }), createElement(TemplatePlaceholder, null));\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return tableRow.type === TABLE_REORDERING_TYPE;\n      }\n    }, function (params) {\n      return createElement(Row, _assign({}, params));\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return tableRow.type === TABLE_REORDERING_TYPE;\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var tableColumns = _a.tableColumns;\n        return createElement(Cell, _assign({}, params, {\n          getCellDimensions: function getCellDimensions(getter) {\n            return _this.storeCellDimensionsGetter(params.tableColumn, getter, tableColumns);\n          }\n        }));\n      });\n    }));\n  };\n\n  TableColumnReorderingRaw.defaultProps = {\n    defaultOrder: []\n  };\n  TableColumnReorderingRaw.components = {\n    tableContainerComponent: 'TableContainer',\n    rowComponent: 'Row',\n    cellComponent: 'Cell'\n  };\n  return TableColumnReorderingRaw;\n}(PureComponent);\n\nvar TableContainer = function TableContainer(_a) {\n  var onOver = _a.onOver,\n      onLeave = _a.onLeave,\n      onDrop = _a.onDrop,\n      children = _a.children,\n      draggingEnabled = _a.draggingEnabled;\n  return draggingEnabled ? createElement(DropTarget, {\n    onOver: onOver,\n    onLeave: onLeave,\n    onDrop: onDrop\n  }, children) : children;\n};\n/** A plugin that manages the displayed columns' order. */\n\n\nvar TableColumnReordering = withComponents({\n  TableContainer: TableContainer\n})(TableColumnReorderingRaw);\n\nvar RowPlaceholder = function RowPlaceholder(props) {\n  return createElement(TemplatePlaceholder, {\n    name: \"tableRow\",\n    params: props\n  });\n};\n\nvar CellPlaceholder = function CellPlaceholder(props) {\n  return createElement(TemplatePlaceholder, {\n    name: \"tableCell\",\n    params: props\n  });\n};\n\nvar tableHeaderRows = [];\n\nvar tableBodyRowsComputed = function tableBodyRowsComputed(_a) {\n  var rows = _a.rows,\n      getRowId = _a.getRowId;\n  return tableRowsWithDataRows(rows, getRowId);\n};\n\nvar tableFooterRows = [];\nvar defaultMessages = {\n  noData: 'No data'\n};\n\nvar TableBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableBase, _super);\n\n  function TableBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.tableColumnsComputed = memoize(function (columnExtensions) {\n      return function (_a) {\n        var columns = _a.columns;\n        return tableColumnsWithDataRows(columns, columnExtensions);\n      };\n    });\n    return _this;\n  }\n\n  TableBase.prototype.render = function () {\n    var _a = this.props,\n        Layout = _a.layoutComponent,\n        Cell = _a.cellComponent,\n        Row = _a.rowComponent,\n        NoDataRow = _a.noDataRowComponent,\n        NoDataCell = _a.noDataCellComponent,\n        StubRow = _a.stubRowComponent,\n        StubCell = _a.stubCellComponent,\n        StubHeaderCell = _a.stubHeaderCellComponent,\n        columnExtensions = _a.columnExtensions,\n        messages = _a.messages,\n        containerComponent = _a.containerComponent,\n        tableComponent = _a.tableComponent,\n        headComponent = _a.headComponent,\n        bodyComponent = _a.bodyComponent,\n        footerComponent = _a.footerComponent;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages, messages));\n    var tableColumnsComputed = this.tableColumnsComputed(columnExtensions);\n    return createElement(Plugin, {\n      name: \"Table\"\n    }, createElement(Getter, {\n      name: \"tableHeaderRows\",\n      value: tableHeaderRows\n    }), createElement(Getter, {\n      name: \"tableBodyRows\",\n      computed: tableBodyRowsComputed\n    }), createElement(Getter, {\n      name: \"tableFooterRows\",\n      value: tableFooterRows\n    }), createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsComputed\n    }), createElement(Getter, {\n      name: \"getTableCellColSpan\",\n      value: tableCellColSpanGetter\n    }), createElement(Template, {\n      name: \"body\"\n    }, createElement(TemplatePlaceholder, {\n      name: \"table\"\n    })), createElement(Template, {\n      name: \"table\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var headerRows = _a.tableHeaderRows,\n          bodyRows = _a.tableBodyRows,\n          footerRows = _a.tableFooterRows,\n          columns = _a.tableColumns,\n          getTableCellColSpan = _a.getTableCellColSpan;\n      return createElement(Layout, {\n        tableComponent: tableComponent,\n        headComponent: headComponent,\n        bodyComponent: bodyComponent,\n        footerComponent: footerComponent,\n        containerComponent: containerComponent,\n        headerRows: headerRows,\n        bodyRows: bodyRows,\n        footerRows: footerRows,\n        columns: columns,\n        rowComponent: RowPlaceholder,\n        cellComponent: CellPlaceholder,\n        getCellColSpan: getTableCellColSpan\n      });\n    })), createElement(Template, {\n      name: \"tableCell\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var headerRows = _a.tableHeaderRows;\n        return isHeaderStubTableCell(params.tableRow, headerRows) ? createElement(StubHeaderCell, _assign({}, params)) : createElement(StubCell, _assign({}, params));\n      });\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isDataTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var getCellValue = _a.getCellValue;\n        var columnName = params.tableColumn.column.name;\n        var value = getCellValue(params.tableRow.row, columnName);\n        return createElement(TemplatePlaceholder, {\n          name: \"valueFormatter\",\n          params: {\n            value: value,\n            row: params.tableRow.row,\n            column: params.tableColumn.column\n          }\n        }, function (content) {\n          return createElement(Cell, _assign({}, params, {\n            row: params.tableRow.row,\n            column: params.tableColumn.column,\n            value: value\n          }), content);\n        });\n      });\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isNoDataTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var tableColumns = _a.tableColumns;\n\n        if (isNoDataTableCell(params.tableColumn, tableColumns)) {\n          return createElement(NoDataCell, _assign({}, params, {\n            getMessage: getMessage\n          }));\n        }\n\n        return null;\n      });\n    }), createElement(Template, {\n      name: \"tableRow\"\n    }, function (params) {\n      return createElement(StubRow, _assign({}, params));\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isDataTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(Row, _assign({}, params, {\n        row: params.tableRow.row\n      }));\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isNoDataTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(NoDataRow, _assign({}, params));\n    }));\n  };\n\n  TableBase.COLUMN_TYPE = TABLE_DATA_TYPE;\n  TableBase.ROW_TYPE = TABLE_DATA_TYPE;\n  TableBase.NODATA_ROW_TYPE = TABLE_NODATA_TYPE;\n  TableBase.defaultProps = {\n    messages: {}\n  };\n  TableBase.components = {\n    tableComponent: 'Table',\n    headComponent: 'TableHead',\n    bodyComponent: 'TableBody',\n    footerComponent: 'TableFooter',\n    containerComponent: 'Container',\n    layoutComponent: 'Layout',\n    rowComponent: 'Row',\n    cellComponent: 'Cell',\n    noDataRowComponent: 'NoDataRow',\n    noDataCellComponent: 'NoDataCell',\n    stubRowComponent: 'StubRow',\n    stubCellComponent: 'StubCell',\n    stubHeaderCellComponent: 'StubHeaderCell'\n  };\n  return TableBase;\n}(PureComponent);\n/***\r\n * A plugin that renders Grid data as a table. This plugin enables you to customize\r\n * table rows and columns, and contains the Table Row and Table Cell components\r\n * that can be extended by other plugins\r\n * */\n\n\nvar Table = TableBase;\n\nvar TableSelectionBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableSelectionBase, _super);\n\n  function TableSelectionBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableSelectionBase.prototype.render = function () {\n    var _a = this.props,\n        highlightRow = _a.highlightRow,\n        selectByRowClick = _a.selectByRowClick,\n        showSelectionColumn = _a.showSelectionColumn,\n        showSelectAll = _a.showSelectAll,\n        HeaderCell = _a.headerCellComponent,\n        Cell = _a.cellComponent,\n        Row = _a.rowComponent,\n        selectionColumnWidth = _a.selectionColumnWidth;\n\n    var tableColumnsComputed = function tableColumnsComputed(_a) {\n      var tableColumns = _a.tableColumns;\n      return tableColumnsWithSelection(tableColumns, selectionColumnWidth);\n    };\n\n    return createElement(Plugin, {\n      name: \"TableSelection\",\n      dependencies: [{\n        name: 'Table'\n      }, {\n        name: 'SelectionState'\n      }, {\n        name: 'IntegratedSelection',\n        optional: !showSelectAll\n      }]\n    }, showSelectionColumn && createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsComputed\n    }), showSelectionColumn && showSelectAll && createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isSelectAllTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var selectAllAvailable = _a.selectAllAvailable,\n            allSelected = _a.allSelected,\n            someSelected = _a.someSelected;\n        var toggleSelectAll = _b.toggleSelectAll;\n        return createElement(HeaderCell, _assign({}, params, {\n          disabled: !selectAllAvailable,\n          allSelected: allSelected,\n          someSelected: someSelected,\n          onToggle: function onToggle(select) {\n            return toggleSelectAll(select);\n          }\n        }));\n      });\n    }), showSelectionColumn && createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isSelectTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var selection = _a.selection;\n        var toggleSelection = _b.toggleSelection;\n        return createElement(Cell, _assign({}, params, {\n          row: params.tableRow.row,\n          selected: selection.indexOf(params.tableRow.rowId) !== -1,\n          onToggle: function onToggle() {\n            return toggleSelection({\n              rowIds: [params.tableRow.rowId]\n            });\n          }\n        }));\n      });\n    }), (highlightRow || selectByRowClick) && createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isDataTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var selection = _a.selection;\n        var toggleSelection = _b.toggleSelection;\n        return createElement(Row, _assign({}, params, {\n          selectByRowClick: selectByRowClick,\n          selected: highlightRow && selection.indexOf(params.tableRow.rowId) !== -1,\n          onToggle: function onToggle() {\n            return toggleSelection({\n              rowIds: [params.tableRow.rowId]\n            });\n          }\n        }));\n      });\n    }));\n  };\n\n  TableSelectionBase.defaultProps = {\n    highlightRow: false,\n    selectByRowClick: false,\n    showSelectAll: false,\n    showSelectionColumn: true\n  };\n  TableSelectionBase.components = {\n    rowComponent: 'Row',\n    cellComponent: 'Cell',\n    headerCellComponent: 'HeaderCell'\n  };\n  TableSelectionBase.COLUMN_TYPE = TABLE_SELECT_TYPE;\n  return TableSelectionBase;\n}(PureComponent);\n/***\r\n * A plugin that visualizes table rows' selection state by rendering selection checkboxes\r\n * and highlighting the selected rows.\r\n * */\n\n\nvar TableSelection = TableSelectionBase; // tslint:disable-next-line: max-line-length\n\nvar RowDetailStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RowDetailStateBase, _super);\n\n  function RowDetailStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds\n    };\n    var stateHelper = createStateHelper(_this, {\n      expandedRowIds: function expandedRowIds() {\n        var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;\n        return onExpandedRowIdsChange;\n      }\n    });\n    _this.toggleDetailRowExpanded = stateHelper.applyFieldReducer.bind(stateHelper, 'expandedRowIds', toggleDetailRowExpanded);\n    return _this;\n  }\n\n  RowDetailStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.expandedRowIds,\n        expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;\n    return {\n      expandedRowIds: expandedRowIds\n    };\n  };\n\n  RowDetailStateBase.prototype.render = function () {\n    var expandedRowIds = this.state.expandedRowIds;\n    return createElement(Plugin, {\n      name: \"RowDetailState\"\n    }, createElement(Getter, {\n      name: \"expandedDetailRowIds\",\n      value: expandedRowIds\n    }), createElement(Action, {\n      name: \"toggleDetailRowExpanded\",\n      action: this.toggleDetailRowExpanded\n    }));\n  };\n\n  RowDetailStateBase.defaultProps = {\n    defaultExpandedRowIds: []\n  };\n  return RowDetailStateBase;\n}(PureComponent);\n/** A plugin that manages the expanded state for table row details. */\n\n\nvar RowDetailState = RowDetailStateBase;\n\nvar getCellColSpanComputed = function getCellColSpanComputed(_a) {\n  var getTableCellColSpan = _a.getTableCellColSpan;\n  return tableDetailCellColSpanGetter(getTableCellColSpan);\n};\n\nvar pluginDependencies$9 = [{\n  name: 'RowDetailState'\n}, {\n  name: 'Table'\n}];\n\nvar TableRowDetailBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableRowDetailBase, _super);\n\n  function TableRowDetailBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableRowDetailBase.prototype.render = function () {\n    var _a = this.props,\n        rowHeight = _a.rowHeight,\n        Content = _a.contentComponent,\n        ToggleCell = _a.toggleCellComponent,\n        Cell = _a.cellComponent,\n        Row = _a.rowComponent,\n        toggleColumnWidth = _a.toggleColumnWidth;\n\n    var tableColumnsComputed = function tableColumnsComputed(_a) {\n      var tableColumns = _a.tableColumns;\n      return tableColumnsWithDetail(tableColumns, toggleColumnWidth);\n    };\n\n    var tableBodyRowsComputed = function tableBodyRowsComputed(_a) {\n      var tableBodyRows = _a.tableBodyRows,\n          expandedDetailRowIds = _a.expandedDetailRowIds;\n      return tableRowsWithExpandedDetail(tableBodyRows, expandedDetailRowIds, rowHeight);\n    };\n\n    return createElement(Plugin, {\n      name: \"TableRowDetail\",\n      dependencies: pluginDependencies$9\n    }, createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsComputed\n    }), createElement(Getter, {\n      name: \"tableBodyRows\",\n      computed: tableBodyRowsComputed\n    }), createElement(Getter, {\n      name: \"getTableCellColSpan\",\n      computed: getCellColSpanComputed\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isDetailToggleTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var expandedDetailRowIds = _a.expandedDetailRowIds;\n        var toggleDetailRowExpanded = _b.toggleDetailRowExpanded;\n        return createElement(ToggleCell, _assign({}, params, {\n          row: params.tableRow.row,\n          expanded: isDetailRowExpanded(expandedDetailRowIds, params.tableRow.rowId),\n          onToggle: function onToggle() {\n            return toggleDetailRowExpanded({\n              rowId: params.tableRow.rowId\n            });\n          }\n        }));\n      });\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isDetailTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var tableColumns = _a.tableColumns;\n\n        if (isDetailTableCell(params.tableColumn, tableColumns)) {\n          return createElement(Cell, _assign({}, params, {\n            row: params.tableRow.row\n          }), Content && createElement(Content, {\n            row: params.tableRow.row\n          }));\n        }\n\n        return null;\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isDetailTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(Row, _assign({}, params, {\n        row: params.tableRow.row\n      }));\n    }));\n  };\n\n  TableRowDetailBase.ROW_TYPE = TABLE_DETAIL_TYPE;\n  TableRowDetailBase.COLUMN_TYPE = TABLE_DETAIL_TYPE;\n  TableRowDetailBase.defaultProps = {\n    contentComponent: function contentComponent() {\n      return null;\n    }\n  };\n  TableRowDetailBase.components = {\n    rowComponent: 'Row',\n    cellComponent: 'Cell',\n    toggleCellComponent: 'ToggleCell'\n  };\n  return TableRowDetailBase;\n}(PureComponent);\n/** A plugin that renders detail rows. */\n\n\nvar TableRowDetail = TableRowDetailBase;\nvar pluginDependencies$a = [{\n  name: 'GroupingState'\n}, {\n  name: 'Table'\n}, {\n  name: 'DataTypeProvider',\n  optional: true\n}, {\n  name: 'TableSelection',\n  optional: true\n}];\n\nvar tableBodyRowsComputed$1 = function tableBodyRowsComputed$1(_a) {\n  var tableBodyRows = _a.tableBodyRows,\n      isGroupRow = _a.isGroupRow;\n  return tableRowsWithGrouping(tableBodyRows, isGroupRow);\n};\n\nvar getCellColSpanComputed$1 = function getCellColSpanComputed$1(_a) {\n  var getTableCellColSpan = _a.getTableCellColSpan;\n  return tableGroupCellColSpanGetter(getTableCellColSpan);\n};\n\nvar showColumnWhenGroupedGetter = function showColumnWhenGroupedGetter(showColumnsWhenGrouped, columnExtensions) {\n  if (columnExtensions === void 0) {\n    columnExtensions = [];\n  }\n\n  var map = columnExtensions.reduce(function (acc, columnExtension) {\n    acc[columnExtension.columnName] = columnExtension.showWhenGrouped;\n    return acc;\n  }, {});\n  return function (columnName) {\n    return map[columnName] || showColumnsWhenGrouped;\n  };\n};\n\nvar TableGroupRowBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableGroupRowBase, _super);\n\n  function TableGroupRowBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableGroupRowBase.prototype.render = function () {\n    var _a = this.props,\n        GroupCell = _a.cellComponent,\n        Content = _a.contentComponent,\n        Icon = _a.iconComponent,\n        GroupRow = _a.rowComponent,\n        GroupIndentCell = _a.indentCellComponent,\n        indentColumnWidth = _a.indentColumnWidth,\n        showColumnsWhenGrouped = _a.showColumnsWhenGrouped,\n        columnExtensions = _a.columnExtensions;\n\n    var tableColumnsComputed = function tableColumnsComputed(_a) {\n      var columns = _a.columns,\n          tableColumns = _a.tableColumns,\n          grouping = _a.grouping,\n          draftGrouping = _a.draftGrouping;\n      return tableColumnsWithGrouping(columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGroupedGetter(showColumnsWhenGrouped, columnExtensions));\n    };\n\n    return createElement(Plugin, {\n      name: \"TableGroupRow\",\n      dependencies: pluginDependencies$a\n    }, createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsComputed\n    }), createElement(Getter, {\n      name: \"tableBodyRows\",\n      computed: tableBodyRowsComputed$1\n    }), createElement(Getter, {\n      name: \"getTableCellColSpan\",\n      computed: getCellColSpanComputed$1\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return isGroupTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var grouping = _a.grouping,\n            expandedGroups = _a.expandedGroups;\n        var toggleGroupExpanded = _b.toggleGroupExpanded;\n\n        if (isGroupTableCell(params.tableRow, params.tableColumn)) {\n          return createElement(TemplatePlaceholder, {\n            name: \"valueFormatter\",\n            params: {\n              column: params.tableColumn.column,\n              value: params.tableRow.row.value\n            }\n          }, function (content) {\n            return createElement(GroupCell, _assign({}, params, {\n              contentComponent: Content,\n              iconComponent: Icon,\n              row: params.tableRow.row,\n              column: params.tableColumn.column,\n              expanded: expandedGroups.indexOf(params.tableRow.row.compoundKey) !== -1,\n              onToggle: function onToggle() {\n                return toggleGroupExpanded({\n                  groupKey: params.tableRow.row.compoundKey\n                });\n              }\n            }), content);\n          });\n        }\n\n        if (isGroupIndentTableCell(params.tableRow, params.tableColumn, grouping)) {\n          if (GroupIndentCell) {\n            return createElement(GroupIndentCell, _assign({}, params, {\n              row: params.tableRow.row,\n              column: params.tableColumn.column\n            }));\n          }\n\n          return createElement(TemplatePlaceholder, null);\n        }\n\n        return null;\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return isGroupTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(GroupRow, _assign({}, params, {\n        row: params.tableRow.row\n      }));\n    }));\n  };\n\n  TableGroupRowBase.ROW_TYPE = TABLE_GROUP_TYPE;\n  TableGroupRowBase.COLUMN_TYPE = TABLE_GROUP_TYPE;\n  TableGroupRowBase.defaultProps = {\n    showColumnsWhenGrouped: false\n  };\n  TableGroupRowBase.components = {\n    rowComponent: 'Row',\n    cellComponent: 'Cell',\n    contentComponent: 'Content',\n    iconComponent: 'Icon'\n  };\n  return TableGroupRowBase;\n}(PureComponent);\n/** A plugin that renders group rows and enables them to expand and collapse. */\n\n\nvar TableGroupRow = TableGroupRowBase;\n\nvar tableHeaderRowsComputed$1 = function tableHeaderRowsComputed$1(_a) {\n  var tableHeaderRows = _a.tableHeaderRows;\n  return tableRowsWithHeading(tableHeaderRows);\n};\n\nvar TableHeaderRowBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableHeaderRowBase, _super);\n\n  function TableHeaderRowBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableHeaderRowBase.prototype.render = function () {\n    var _a = this.props,\n        showSortingControls = _a.showSortingControls,\n        showGroupingControls = _a.showGroupingControls,\n        HeaderCell = _a.cellComponent,\n        HeaderRow = _a.rowComponent,\n        Content = _a.contentComponent,\n        SortLabel = _a.sortLabelComponent,\n        GroupButton = _a.groupButtonComponent,\n        Title = _a.titleComponent,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(messages);\n    return createElement(Plugin, {\n      name: \"TableHeaderRow\",\n      dependencies: [{\n        name: 'Table'\n      }, {\n        name: 'SortingState',\n        optional: !showSortingControls\n      }, {\n        name: 'GroupingState',\n        optional: !showGroupingControls\n      }, {\n        name: 'DragDropProvider',\n        optional: true\n      }, {\n        name: 'TableColumnResizing',\n        optional: true\n      }]\n    }, createElement(Getter, {\n      name: \"tableHeaderRows\",\n      computed: tableHeaderRowsComputed$1\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isHeadingTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var sorting = _a.sorting,\n            tableColumns = _a.tableColumns,\n            draggingEnabled = _a.draggingEnabled,\n            tableColumnResizingEnabled = _a.tableColumnResizingEnabled,\n            isColumnSortingEnabled = _a.isColumnSortingEnabled,\n            isColumnGroupingEnabled = _a.isColumnGroupingEnabled;\n        var changeColumnSorting = _b.changeColumnSorting,\n            changeColumnGrouping = _b.changeColumnGrouping,\n            changeTableColumnWidth = _b.changeTableColumnWidth,\n            draftTableColumnWidth = _b.draftTableColumnWidth,\n            cancelTableColumnWidthDraft = _b.cancelTableColumnWidthDraft;\n        var _c = params.tableColumn.column,\n            columnName = _c.name,\n            columnTitle = _c.title;\n        var atLeastOneDataColumn = tableColumns.filter(function (_a) {\n          var type = _a.type;\n          return type === TABLE_DATA_TYPE;\n        }).length > 1;\n        var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);\n        var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName) && atLeastOneDataColumn;\n        return createElement(HeaderCell, _assign({}, params, {\n          column: params.tableColumn.column,\n          draggingEnabled: draggingEnabled && atLeastOneDataColumn,\n          resizingEnabled: tableColumnResizingEnabled,\n          onWidthChange: function onWidthChange(_a) {\n            var shift = _a.shift;\n            return changeTableColumnWidth({\n              columnName: columnName,\n              shift: shift\n            });\n          },\n          onWidthDraft: function onWidthDraft(_a) {\n            var shift = _a.shift;\n            return draftTableColumnWidth({\n              columnName: columnName,\n              shift: shift\n            });\n          },\n          onWidthDraftCancel: function onWidthDraftCancel() {\n            return cancelTableColumnWidthDraft();\n          },\n          // @deprecated\n          sortingEnabled: sortingEnabled,\n          // @deprecated\n          groupingEnabled: groupingEnabled,\n          // @deprecated\n          showSortingControls: showSortingControls,\n          // @deprecated\n          showGroupingControls: showGroupingControls,\n          // @deprecated\n          sortingDirection: showSortingControls && sorting !== undefined ? getColumnSortingDirection(sorting, columnName) : undefined,\n          // @deprecated\n          onSort: function onSort(_a) {\n            var direction = _a.direction,\n                keepOther = _a.keepOther;\n            return changeColumnSorting({\n              columnName: columnName,\n              direction: direction,\n              keepOther: keepOther\n            });\n          },\n          // @deprecated\n          onGroup: function onGroup() {\n            return changeColumnGrouping({\n              columnName: columnName\n            });\n          },\n          // @deprecated\n          before: createElement(TemplatePlaceholder, {\n            name: \"tableHeaderCellBefore\",\n            params: {\n              column: params.tableColumn.column\n            }\n          })\n        }), createElement(TemplatePlaceholder, {\n          name: \"tableHeaderCellBefore\",\n          params: {\n            column: params.tableColumn.column\n          }\n        }), createElement(Content, {\n          column: params.tableColumn.column,\n          align: params.tableColumn.align\n        }, showSortingControls ? createElement(SortLabel, {\n          column: params.tableColumn.column,\n          align: params.tableColumn.align,\n          direction: getColumnSortingDirection(sorting, columnName) || null,\n          disabled: !sortingEnabled,\n          onSort: function onSort(_a) {\n            var direction = _a.direction,\n                keepOther = _a.keepOther;\n            changeColumnSorting({\n              columnName: columnName,\n              direction: direction,\n              keepOther: keepOther\n            });\n          },\n          getMessage: getMessage\n        }, createElement(Title, null, columnTitle || columnName)) : createElement(Title, null, columnTitle || columnName)), showGroupingControls ? createElement(GroupButton, {\n          disabled: !groupingEnabled,\n          onGroup: function onGroup() {\n            return changeColumnGrouping({\n              columnName: columnName\n            });\n          }\n        }) : null);\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isHeadingTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(HeaderRow, _assign({}, params));\n    }));\n  };\n\n  TableHeaderRowBase.ROW_TYPE = TABLE_HEADING_TYPE;\n  TableHeaderRowBase.defaultProps = {\n    showSortingControls: false,\n    showGroupingControls: false,\n    messages: {}\n  };\n  TableHeaderRowBase.components = {\n    cellComponent: 'Cell',\n    rowComponent: 'Row',\n    contentComponent: 'Content',\n    sortLabelComponent: 'SortLabel',\n    titleComponent: 'Title',\n    groupButtonComponent: 'GroupButton'\n  };\n  return TableHeaderRowBase;\n}(PureComponent);\n\nTableHeaderRowBase.components = {\n  cellComponent: 'Cell',\n  rowComponent: 'Row',\n  contentComponent: 'Content',\n  sortLabelComponent: 'SortLabel',\n  titleComponent: 'Title',\n  groupButtonComponent: 'GroupButton'\n};\n/***\r\n * A plugin that renders the table's header row. The Column's `title` field specifies the\r\n * column's title in the header row.The plugin also allows you to manage a column's sorting\r\n * and grouping state and initiate column dragging.\r\n * */\n\nvar TableHeaderRow = TableHeaderRowBase;\n\nvar CellPlaceholder$1 = function CellPlaceholder$1(props) {\n  return createElement(TemplatePlaceholder, {\n    params: props\n  });\n};\n\nvar TableBandHeaderBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableBandHeaderBase, _super);\n\n  function TableBandHeaderBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableBandHeaderBase.prototype.render = function () {\n    var _a = this.props,\n        Cell = _a.cellComponent,\n        Row = _a.rowComponent,\n        HeaderCell = _a.bandedHeaderCellComponent,\n        InvisibleCell = _a.invisibleCellComponent,\n        columnBands = _a.columnBands;\n\n    var tableHeaderRowsComputed = function tableHeaderRowsComputed(_a) {\n      var tableHeaderRows = _a.tableHeaderRows,\n          tableColumns = _a.tableColumns;\n      return tableRowsWithBands(tableHeaderRows, columnBands, tableColumns);\n    };\n\n    var tableHeaderColumnChainsComputed = function tableHeaderColumnChainsComputed(_a) {\n      var tableHeaderRows = _a.tableHeaderRows,\n          tableColumns = _a.tableColumns;\n      return tableHeaderColumnChainsWithBands(tableHeaderRows, tableColumns, columnBands);\n    };\n\n    return createElement(Plugin, {\n      name: \"TableBandHeader\",\n      dependencies: [{\n        name: 'Table'\n      }, {\n        name: 'TableHeaderRow'\n      }, {\n        name: 'TableSelection',\n        optional: true\n      }, {\n        name: 'TableEditColumn',\n        optional: true\n      }]\n    }, createElement(Getter, {\n      name: \"tableHeaderRows\",\n      computed: tableHeaderRowsComputed\n    }), createElement(Getter, {\n      name: \"tableHeaderColumnChains\",\n      computed: tableHeaderColumnChainsComputed\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isBandedOrHeaderRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var tableColumns = _a.tableColumns,\n            tableHeaderRows = _a.tableHeaderRows,\n            tableHeaderColumnChains = _a.tableHeaderColumnChains;\n        var bandComponent = getBandComponent(params, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains);\n\n        switch (bandComponent.type) {\n          case BAND_DUPLICATE_RENDER:\n            return createElement(TemplatePlaceholder, null);\n\n          case BAND_EMPTY_CELL:\n            return createElement(InvisibleCell, null);\n\n          case BAND_GROUP_CELL:\n            {\n              var _b = bandComponent.payload,\n                  value = _b.value,\n                  payload = __rest(_b, [\"value\"]);\n\n              return createElement(Cell, _assign({}, params, payload), value);\n            }\n\n          case BAND_HEADER_CELL:\n            return createElement(TemplatePlaceholder, {\n              name: \"tableCell\",\n              params: _assign({}, params, bandComponent.payload)\n            });\n\n          default:\n            return null;\n        }\n      });\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isHeadingTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(HeaderCell, _assign({\n        component: CellPlaceholder$1\n      }, params));\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isBandedTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(Row, _assign({}, params));\n    }));\n  };\n\n  TableBandHeaderBase.ROW_TYPE = TABLE_BAND_TYPE;\n  TableBandHeaderBase.components = {\n    cellComponent: 'Cell',\n    rowComponent: 'Row',\n    bandedHeaderCellComponent: 'BandedHeaderCell',\n    invisibleCellComponent: 'InvisibleCell'\n  };\n  return TableBandHeaderBase;\n}(PureComponent);\n\nTableBandHeaderBase.components = {\n  cellComponent: 'Cell',\n  rowComponent: 'Row',\n  bandedHeaderCellComponent: 'BandedHeaderCell',\n  invisibleCellComponent: 'InvisibleCell'\n};\n/** A plugin that renders the banded cells. */\n\nvar TableBandHeader = TableBandHeaderBase;\nvar pluginDependencies$b = [{\n  name: 'FilteringState'\n}, {\n  name: 'Table'\n}, {\n  name: 'DataTypeProvider',\n  optional: true\n}];\nvar defaultMessages$1 = {\n  filterPlaceholder: 'Filter...',\n  contains: 'Contains',\n  notContains: 'Does not contain',\n  startsWith: 'Starts with',\n  endsWith: 'Ends with',\n  equal: 'Equals',\n  notEqual: 'Does not equal',\n  greaterThan: 'Greater than',\n  greaterThanOrEqual: 'Greater than or equal to',\n  lessThan: 'Less than',\n  lessThanOrEqual: 'Less than or equal to'\n};\n\nvar TableFilterRowBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableFilterRowBase, _super);\n\n  function TableFilterRowBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      filterOperations: {}\n    };\n    return _this;\n  }\n\n  TableFilterRowBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        rowHeight = _a.rowHeight,\n        showFilterSelector = _a.showFilterSelector,\n        FilterCell = _a.cellComponent,\n        FilterRow = _a.rowComponent,\n        FilterSelector = _a.filterSelectorComponent,\n        iconComponent = _a.iconComponent,\n        toggleButtonComponent = _a.toggleButtonComponent,\n        EditorComponent = _a.editorComponent,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages$1, messages));\n\n    var tableHeaderRowsComputed = function tableHeaderRowsComputed(_a) {\n      var tableHeaderRows = _a.tableHeaderRows;\n      return tableHeaderRowsWithFilter(tableHeaderRows, rowHeight);\n    };\n\n    return createElement(Plugin, {\n      name: \"TableFilterRow\",\n      dependencies: pluginDependencies$b\n    }, createElement(Getter, {\n      name: \"tableHeaderRows\",\n      computed: tableHeaderRowsComputed\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isFilterTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var filters = _a.filters,\n            isColumnFilteringEnabled = _a.isColumnFilteringEnabled,\n            getAvailableFilterOperations = _a.getAvailableFilterOperations;\n        var changeColumnFilter = _b.changeColumnFilter;\n        var filterOperations = _this.state.filterOperations;\n        var columnName = params.tableColumn.column.name;\n        var filter = getColumnFilterConfig(filters, columnName);\n\n        var onFilter = function onFilter(config) {\n          return changeColumnFilter({\n            columnName: columnName,\n            config: config\n          });\n        };\n\n        var columnFilterOperations = getColumnFilterOperations(getAvailableFilterOperations, columnName);\n        var selectedFilterOperation = getSelectedFilterOperation(filterOperations, columnName, filter, columnFilterOperations);\n\n        var handleFilterOperationChange = function handleFilterOperationChange(value) {\n          var _a;\n\n          _this.setState({\n            filterOperations: _assign({}, filterOperations, (_a = {}, _a[columnName] = value, _a))\n          });\n\n          if (filter && !isFilterValueEmpty(filter.value)) {\n            onFilter({\n              value: filter.value,\n              operation: value\n            });\n          }\n        };\n\n        var handleFilterValueChange = function handleFilterValueChange(value) {\n          return onFilter(!isFilterValueEmpty(value) ? {\n            value: value,\n            operation: selectedFilterOperation\n          } : null);\n        };\n\n        var filteringEnabled = isColumnFilteringEnabled(columnName);\n        return createElement(TemplatePlaceholder, {\n          name: \"valueEditor\",\n          params: {\n            column: params.tableColumn.column,\n            value: filter ? filter.value : undefined,\n            onValueChange: handleFilterValueChange\n          }\n        }, function (content) {\n          return createElement(FilterCell, _assign({}, params, {\n            getMessage: getMessage,\n            column: params.tableColumn.column,\n            filter: filter,\n            filteringEnabled: filteringEnabled,\n            onFilter: onFilter\n          }), showFilterSelector ? createElement(FilterSelector, {\n            toggleButtonComponent: toggleButtonComponent,\n            iconComponent: iconComponent,\n            value: selectedFilterOperation,\n            availableValues: columnFilterOperations,\n            onChange: handleFilterOperationChange,\n            disabled: !filteringEnabled,\n            getMessage: getMessage\n          }) : null, content || createElement(EditorComponent, {\n            value: filter ? filter.value : undefined,\n            disabled: !filteringEnabled,\n            getMessage: getMessage,\n            onChange: handleFilterValueChange\n          }));\n        });\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isFilterTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(FilterRow, _assign({}, params));\n    }));\n  };\n\n  TableFilterRowBase.ROW_TYPE = TABLE_FILTER_TYPE;\n  TableFilterRowBase.defaultProps = {\n    showFilterSelector: false,\n    messages: {}\n  };\n  TableFilterRowBase.components = {\n    rowComponent: 'Row',\n    cellComponent: 'Cell',\n    filterSelectorComponent: 'FilterSelector',\n    iconComponent: 'Icon',\n    editorComponent: 'Editor',\n    toggleButtonComponent: 'ToggleButton'\n  };\n  return TableFilterRowBase;\n}(PureComponent);\n/** A plugin that renders a filter row. */\n\n\nvar TableFilterRow = TableFilterRowBase;\nvar pluginDependencies$c = [{\n  name: 'EditingState'\n}, {\n  name: 'Table'\n}, {\n  name: 'DataTypeProvider',\n  optional: true\n}];\n\nvar TableEditRowBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableEditRowBase, _super);\n\n  function TableEditRowBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableEditRowBase.prototype.render = function () {\n    var _a = this.props,\n        EditCell = _a.cellComponent,\n        EditRow = _a.rowComponent,\n        rowHeight = _a.rowHeight;\n\n    var tableBodyRowsComputed = function tableBodyRowsComputed(_a) {\n      var tableBodyRows = _a.tableBodyRows,\n          editingRowIds = _a.editingRowIds,\n          addedRows = _a.addedRows;\n      return tableRowsWithEditing(tableBodyRows, editingRowIds, addedRows, rowHeight);\n    };\n\n    return createElement(Plugin, {\n      name: \"TableEditRow\",\n      dependencies: pluginDependencies$c\n    }, createElement(Getter, {\n      name: \"tableBodyRows\",\n      computed: tableBodyRowsComputed\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isEditTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var getCellValue = _a.getCellValue,\n            createRowChange = _a.createRowChange,\n            rowChanges = _a.rowChanges,\n            isColumnEditingEnabled = _a.isColumnEditingEnabled;\n        var changeAddedRow = _b.changeAddedRow,\n            changeRow = _b.changeRow;\n        var _c = params.tableRow,\n            rowId = _c.rowId,\n            row = _c.row;\n        var column = params.tableColumn.column;\n        var columnName = column.name;\n        var isNew = isAddedTableRow(params.tableRow);\n        var changedRow = isNew ? row : _assign({}, row, getRowChange(rowChanges, rowId));\n        var value = getCellValue(changedRow, columnName);\n\n        var onValueChange = function onValueChange(newValue) {\n          var changeArgs = {\n            rowId: rowId,\n            change: createRowChange(changedRow, newValue, columnName)\n          };\n\n          if (isNew) {\n            changeAddedRow(changeArgs);\n          } else {\n            changeRow(changeArgs);\n          }\n        };\n\n        return createElement(TemplatePlaceholder, {\n          name: \"valueEditor\",\n          params: {\n            column: column,\n            row: row,\n            value: value,\n            onValueChange: onValueChange\n          }\n        }, function (content) {\n          return createElement(EditCell, _assign({}, params, {\n            row: row,\n            column: column,\n            value: value,\n            editingEnabled: isColumnEditingEnabled(columnName),\n            onValueChange: onValueChange\n          }), content);\n        });\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!(isEditTableRow(tableRow) || isAddedTableRow(tableRow));\n      }\n    }, function (params) {\n      return createElement(EditRow, _assign({}, params, {\n        row: params.tableRow.row\n      }));\n    }));\n  };\n\n  TableEditRowBase.ADDED_ROW_TYPE = TABLE_ADDED_TYPE;\n  TableEditRowBase.EDIT_ROW_TYPE = TABLE_EDIT_TYPE;\n  TableEditRowBase.components = {\n    rowComponent: 'Row',\n    cellComponent: 'Cell'\n  };\n  return TableEditRowBase;\n}(PureComponent);\n/** A plugin that renders a row being edited. */\n\n\nvar TableEditRow = TableEditRowBase;\nvar pluginDependencies$d = [{\n  name: 'EditingState'\n}, {\n  name: 'Table'\n}];\nvar defaultMessages$2 = {\n  addCommand: 'New',\n  editCommand: 'Edit',\n  deleteCommand: 'Delete',\n  commitCommand: 'Save',\n  cancelCommand: 'Cancel'\n};\n\nvar TableEditColumnBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableEditColumnBase, _super);\n\n  function TableEditColumnBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableEditColumnBase.prototype.render = function () {\n    var _a = this.props,\n        Cell = _a.cellComponent,\n        HeaderCell = _a.headerCellComponent,\n        Command = _a.commandComponent,\n        showAddCommand = _a.showAddCommand,\n        showEditCommand = _a.showEditCommand,\n        showDeleteCommand = _a.showDeleteCommand,\n        width = _a.width,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages$2, messages));\n\n    var tableColumnsComputed = function tableColumnsComputed(_a) {\n      var tableColumns = _a.tableColumns;\n      return tableColumnsWithEditing(tableColumns, width);\n    };\n\n    return createElement(Plugin, {\n      name: \"TableEditColumn\",\n      dependencies: pluginDependencies$d\n    }, createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsComputed\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isHeadingEditCommandsTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (getters, actions) {\n        return createElement(HeaderCell, _assign({}, params), showAddCommand && createElement(Command, {\n          id: \"add\",\n          text: getMessage('addCommand'),\n          onExecute: function onExecute() {\n            return actions.addRow();\n          }\n        }));\n      });\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isEditCommandsTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (getters, actions) {\n        var isEdit = isEditTableRow(params.tableRow);\n        var isNew = isAddedTableRow(params.tableRow);\n        var isEditing = isEdit || isNew;\n        var rowIds = [params.tableRow.rowId];\n        return createElement(Cell, _assign({}, params, {\n          row: params.tableRow.row\n        }), showEditCommand && !isEditing && createElement(Command, {\n          id: \"edit\",\n          text: getMessage('editCommand'),\n          onExecute: function onExecute() {\n            return actions.startEditRows({\n              rowIds: rowIds\n            });\n          }\n        }), showDeleteCommand && !isEditing && createElement(Command, {\n          id: \"delete\",\n          text: getMessage('deleteCommand'),\n          onExecute: function onExecute() {\n            actions.deleteRows({\n              rowIds: rowIds\n            });\n            actions.commitDeletedRows({\n              rowIds: rowIds\n            });\n          }\n        }), isEditing && createElement(Command, {\n          id: \"commit\",\n          text: getMessage('commitCommand'),\n          onExecute: function onExecute() {\n            if (isNew) {\n              actions.commitAddedRows({\n                rowIds: rowIds\n              });\n            } else {\n              actions.stopEditRows({\n                rowIds: rowIds\n              });\n              actions.commitChangedRows({\n                rowIds: rowIds\n              });\n            }\n          }\n        }), isEditing && createElement(Command, {\n          id: \"cancel\",\n          text: getMessage('cancelCommand'),\n          onExecute: function onExecute() {\n            if (isNew) {\n              actions.cancelAddedRows({\n                rowIds: rowIds\n              });\n            } else {\n              actions.stopEditRows({\n                rowIds: rowIds\n              });\n              actions.cancelChangedRows({\n                rowIds: rowIds\n              });\n            }\n          }\n        }));\n      });\n    }));\n  };\n\n  TableEditColumnBase.COLUMN_TYPE = TABLE_EDIT_COMMAND_TYPE;\n  TableEditColumnBase.defaultProps = {\n    showAddCommand: false,\n    showEditCommand: false,\n    showDeleteCommand: false,\n    width: 140,\n    messages: {}\n  };\n  TableEditColumnBase.components = {\n    cellComponent: 'Cell',\n    headerCellComponent: 'HeaderCell',\n    commandComponent: 'Command'\n  };\n  return TableEditColumnBase;\n}(PureComponent);\n/***\r\n * A plugin that renders a command column. This column contains controls used for row editing,\r\n * creating, or deleting and committing/canceling changes.\r\n * */\n\n\nvar TableEditColumn = TableEditColumnBase;\nvar pluginDependencies$e = [{\n  name: 'Table'\n}]; // tslint:disable-next-line: max-line-length\n\nvar TableColumnResizingBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableColumnResizingBase, _super);\n\n  function TableColumnResizingBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      columnWidths: props.columnWidths || props.defaultColumnWidths,\n      draftColumnWidths: []\n    };\n    var stateHelper = createStateHelper(_this, {\n      columnWidths: function columnWidths() {\n        var onColumnWidthsChange = _this.props.onColumnWidthsChange;\n        return onColumnWidthsChange;\n      }\n    });\n    _this.tableColumnsComputed = memoize(function (columnWidths) {\n      return function (_a) {\n        var tableColumns = _a.tableColumns;\n        return tableColumnsWithWidths(tableColumns, columnWidths);\n      };\n    });\n    _this.tableColumnsDraftComputed = memoize(function (draftColumnWidths) {\n      return function (_a) {\n        var tableColumns = _a.tableColumns;\n        return tableColumnsWithDraftWidths(tableColumns, draftColumnWidths);\n      };\n    });\n    _this.changeTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {\n      var minColumnWidth = _this.props.minColumnWidth;\n      return changeTableColumnWidth(prevState, _assign({}, payload, {\n        minColumnWidth: minColumnWidth\n      }));\n    });\n    _this.draftTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {\n      var minColumnWidth = _this.props.minColumnWidth;\n      return draftTableColumnWidth(prevState, _assign({}, payload, {\n        minColumnWidth: minColumnWidth\n      }));\n    });\n    _this.cancelTableColumnWidthDraft = stateHelper.applyReducer.bind(stateHelper, cancelTableColumnWidthDraft);\n    return _this;\n  }\n\n  TableColumnResizingBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.columnWidths,\n        columnWidths = _a === void 0 ? prevState.columnWidths : _a;\n    return {\n      columnWidths: columnWidths\n    };\n  };\n\n  TableColumnResizingBase.prototype.render = function () {\n    var _a = this.state,\n        columnWidths = _a.columnWidths,\n        draftColumnWidths = _a.draftColumnWidths;\n    var tableColumnsComputed = this.tableColumnsComputed(columnWidths);\n    var tableColumnsDraftComputed = this.tableColumnsDraftComputed(draftColumnWidths);\n    return createElement(Plugin, {\n      name: \"TableColumnResizing\",\n      dependencies: pluginDependencies$e\n    }, createElement(Getter, {\n      name: \"tableColumnResizingEnabled\",\n      value: true\n    }), createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsComputed\n    }), createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsDraftComputed\n    }), createElement(Action, {\n      name: \"changeTableColumnWidth\",\n      action: this.changeTableColumnWidth\n    }), createElement(Action, {\n      name: \"draftTableColumnWidth\",\n      action: this.draftTableColumnWidth\n    }), createElement(Action, {\n      name: \"cancelTableColumnWidthDraft\",\n      action: this.cancelTableColumnWidthDraft\n    }));\n  };\n\n  TableColumnResizingBase.defaultProps = {\n    defaultColumnWidths: []\n  };\n  return TableColumnResizingBase;\n}(PureComponent);\n/* tslint:disable: max-line-length */\n\n/** A plugin that manages table column widths. */\n\n\nvar TableColumnResizing = TableColumnResizingBase;\n/* tslint:enable: max-line-length */\n\nvar pluginDependencies$f = [{\n  name: 'PagingState'\n}];\nvar defaultMessages$3 = {\n  showAll: 'All',\n  info: function info(_a) {\n    var from = _a.from,\n        to = _a.to,\n        count = _a.count;\n    return \"\" + from + (from < to ? \"-\" + to : '') + \" of \" + count;\n  }\n};\n\nvar PagingPanelBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PagingPanelBase, _super);\n\n  function PagingPanelBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PagingPanelBase.prototype.render = function () {\n    var _a = this.props,\n        Pager = _a.containerComponent,\n        pageSizes = _a.pageSizes,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages$3, messages));\n    return createElement(Plugin, {\n      name: \"PagingPanel\",\n      dependencies: pluginDependencies$f\n    }, createElement(Template, {\n      name: \"footer\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a, _b) {\n      var currentPage = _a.currentPage,\n          pageSize = _a.pageSize,\n          totalCount = _a.totalCount;\n      var setCurrentPage = _b.setCurrentPage,\n          setPageSize = _b.setPageSize;\n      return createElement(Pager, {\n        currentPage: currentPage,\n        pageSize: pageSize,\n        totalCount: totalCount,\n        totalPages: pageCount(totalCount, pageSize),\n        pageSizes: pageSizes,\n        getMessage: getMessage,\n        onCurrentPageChange: setCurrentPage,\n        onPageSizeChange: setPageSize\n      });\n    })));\n  };\n\n  PagingPanelBase.defaultProps = {\n    pageSizes: [],\n    messages: {}\n  };\n  PagingPanelBase.components = {\n    containerComponent: 'Container'\n  };\n  return PagingPanelBase;\n}(PureComponent);\n/** A plugin that renders the paging panel used for navigation through data pages. */\n\n\nvar PagingPanel = PagingPanelBase;\nvar defaultProps = {\n  draggingEnabled: false,\n  onDragStart: function onDragStart() {},\n  onDragEnd: function onDragEnd() {}\n}; // tslint:disable-next-line: max-line-length\n\nvar ItemLayout =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ItemLayout, _super);\n\n  function ItemLayout(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      dragging: false\n    };\n    return _this;\n  }\n\n  ItemLayout.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        item = _a.item,\n        Item = _a.itemComponent,\n        draggingEnabled = _a.draggingEnabled,\n        onDragStart = _a.onDragStart,\n        onDragEnd = _a.onDragEnd;\n    var dragging = this.state.dragging;\n    var itemElement = createElement(Item, {\n      item: _assign({}, item, {\n        draft: dragging || item.draft\n      })\n    });\n    return draggingEnabled ? createElement(DragSource, {\n      payload: [{\n        type: 'column',\n        columnName: item.column.name\n      }],\n      onStart: function onStart() {\n        _this.setState({\n          dragging: true\n        });\n\n        onDragStart();\n      },\n      onEnd: function onEnd() {\n        _this.setState({\n          dragging: false\n        });\n\n        onDragEnd();\n      }\n    }, itemElement) : itemElement;\n  };\n\n  ItemLayout.defaultProps = defaultProps;\n  return ItemLayout;\n}(PureComponent);\n\nvar defaultProps$1 = {\n  onGroup: function onGroup() {},\n  draggingEnabled: false,\n  isColumnGroupingEnabled: function isColumnGroupingEnabled() {\n    return false;\n  },\n  onGroupDraft: function onGroupDraft() {},\n  onGroupDraftCancel: function onGroupDraftCancel() {}\n}; // tslint:disable-next-line: max-line-length\n\nvar GroupPanelLayoutBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(GroupPanelLayoutBase, _super);\n\n  function GroupPanelLayoutBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.itemRefs = [];\n    _this.draggingColumnName = null;\n    _this.state = {\n      sourceColumnName: null,\n      targetItemIndex: -1\n    };\n\n    _this.handleDragEvent = function (eventHandler, _a) {\n      var payload = _a.payload,\n          restArgs = __rest(_a, [\"payload\"]);\n\n      var isColumnGroupingEnabled = _this.props.isColumnGroupingEnabled;\n      var columnName = payload[0].columnName;\n\n      if (isColumnGroupingEnabled(columnName)) {\n        eventHandler(_assign({\n          payload: payload\n        }, restArgs));\n      }\n    };\n\n    _this.onEnter = function (_a) {\n      var payload = _a.payload;\n\n      _this.setState({\n        sourceColumnName: payload[0].columnName\n      });\n    };\n\n    _this.onOver = function (_a) {\n      var clientOffset = _a.clientOffset;\n      var _b = _this.props,\n          onGroupDraft = _b.onGroupDraft,\n          items = _b.items;\n      var _c = _this.state,\n          sourceColumnName = _c.sourceColumnName,\n          prevTargetItemIndex = _c.targetItemIndex; // eslint-disable-next-line react/no-find-dom-node\n\n      var itemGeometries = _this.itemRefs.map(function (ref) {\n        return findDOMNode(ref).getBoundingClientRect();\n      });\n\n      var sourceItemIndex = items.findIndex(function (_a) {\n        var column = _a.column;\n        return column.name === sourceColumnName;\n      });\n      var targetItemIndex = getGroupCellTargetIndex(itemGeometries, sourceItemIndex, clientOffset);\n      if (prevTargetItemIndex === targetItemIndex) return;\n      onGroupDraft({\n        columnName: sourceColumnName,\n        groupIndex: targetItemIndex\n      });\n\n      _this.setState({\n        targetItemIndex: targetItemIndex\n      });\n    };\n\n    _this.onLeave = function () {\n      var onGroupDraft = _this.props.onGroupDraft;\n      var sourceColumnName = _this.state.sourceColumnName;\n\n      if (!_this.draggingColumnName) {\n        _this.resetState();\n\n        return;\n      }\n\n      onGroupDraft({\n        columnName: sourceColumnName,\n        groupIndex: -1\n      });\n\n      _this.setState({\n        targetItemIndex: -1\n      });\n    };\n\n    _this.onDrop = function () {\n      var onGroup = _this.props.onGroup;\n      var _a = _this.state,\n          sourceColumnName = _a.sourceColumnName,\n          targetItemIndex = _a.targetItemIndex;\n\n      _this.resetState();\n\n      onGroup({\n        columnName: sourceColumnName,\n        groupIndex: targetItemIndex\n      });\n    };\n\n    _this.onDragStart = function (columnName) {\n      _this.draggingColumnName = columnName;\n    };\n\n    _this.onDragEnd = function () {\n      _this.draggingColumnName = null;\n      var _a = _this.state,\n          sourceColumnName = _a.sourceColumnName,\n          targetItemIndex = _a.targetItemIndex;\n      var onGroup = _this.props.onGroup;\n\n      if (sourceColumnName && targetItemIndex === -1) {\n        onGroup({\n          columnName: sourceColumnName\n        });\n      }\n\n      _this.resetState();\n    };\n\n    return _this;\n  }\n\n  GroupPanelLayoutBase.prototype.resetState = function () {\n    var onGroupDraftCancel = this.props.onGroupDraftCancel;\n    onGroupDraftCancel();\n    this.setState({\n      sourceColumnName: null,\n      targetItemIndex: -1\n    });\n  };\n\n  GroupPanelLayoutBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        items = _a.items,\n        EmptyMessage = _a.emptyMessageComponent,\n        Container = _a.containerComponent,\n        Item = _a.itemComponent,\n        draggingEnabled = _a.draggingEnabled,\n        isColumnGroupingEnabled = _a.isColumnGroupingEnabled;\n    this.itemRefs = [];\n    var groupPanel = items.length ? createElement(Container, null, items.map(function (item) {\n      var columnName = item.column.name;\n      return createElement(ItemLayout, {\n        key: columnName,\n        ref: function ref(element) {\n          return element && _this.itemRefs.push(element);\n        },\n        item: item,\n        itemComponent: Item,\n        draggingEnabled: draggingEnabled && isColumnGroupingEnabled(columnName),\n        onDragStart: function onDragStart() {\n          return _this.onDragStart(columnName);\n        },\n        onDragEnd: _this.onDragEnd\n      });\n    })) : createElement(EmptyMessage, null);\n    return draggingEnabled ? createElement(DropTarget, {\n      onEnter: function onEnter(args) {\n        return _this.handleDragEvent(_this.onEnter, args);\n      },\n      onOver: function onOver(args) {\n        return _this.handleDragEvent(_this.onOver, args);\n      },\n      onLeave: function onLeave(args) {\n        return _this.handleDragEvent(_this.onLeave, args);\n      },\n      onDrop: function onDrop(args) {\n        return _this.handleDragEvent(_this.onDrop, args);\n      }\n    }, groupPanel) : groupPanel;\n  };\n\n  GroupPanelLayoutBase.defaultProps = defaultProps$1;\n  return GroupPanelLayoutBase;\n}(PureComponent);\n/** @internal */\n\n\nvar GroupPanelLayout = GroupPanelLayoutBase;\nvar defaultMessages$4 = {\n  groupByColumn: 'Drag a column header here to group by that column'\n};\nvar defaultProps$2 = {\n  showSortingControls: false,\n  showGroupingControls: false,\n  messages: {}\n};\n\nvar GroupingPanelRaw =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(GroupingPanelRaw, _super);\n\n  function GroupingPanelRaw() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GroupingPanelRaw.prototype.render = function () {\n    var _a = this.props,\n        LayoutComponent = _a.layoutComponent,\n        Container = _a.containerComponent,\n        Item = _a.itemComponent,\n        EmptyMessage = _a.emptyMessageComponent,\n        showSortingControls = _a.showSortingControls,\n        showGroupingControls = _a.showGroupingControls,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages$4, messages));\n\n    var EmptyMessagePlaceholder = function EmptyMessagePlaceholder() {\n      return createElement(EmptyMessage, {\n        getMessage: getMessage\n      });\n    };\n\n    var ItemPlaceholder = function ItemPlaceholder(_a) {\n      var item = _a.item;\n      var columnName = item.column.name;\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var sorting = _a.sorting,\n            isColumnSortingEnabled = _a.isColumnSortingEnabled,\n            isColumnGroupingEnabled = _a.isColumnGroupingEnabled;\n        var changeColumnGrouping = _b.changeColumnGrouping,\n            changeColumnSorting = _b.changeColumnSorting;\n        var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);\n        var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName);\n        return createElement(Item, {\n          item: item,\n          sortingEnabled: sortingEnabled,\n          groupingEnabled: groupingEnabled,\n          showSortingControls: showSortingControls,\n          sortingDirection: showSortingControls ? getColumnSortingDirection(sorting, columnName) : undefined,\n          showGroupingControls: showGroupingControls,\n          onGroup: function onGroup() {\n            return changeColumnGrouping({\n              columnName: columnName\n            });\n          },\n          onSort: function onSort(_a) {\n            var direction = _a.direction,\n                keepOther = _a.keepOther;\n            return changeColumnSorting({\n              columnName: columnName,\n              direction: direction,\n              keepOther: keepOther\n            });\n          }\n        });\n      });\n    };\n\n    return createElement(Plugin, {\n      name: \"GroupingPanel\",\n      dependencies: [{\n        name: 'GroupingState'\n      }, {\n        name: 'Toolbar'\n      }, {\n        name: 'SortingState',\n        optional: !showSortingControls\n      }]\n    }, createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(TemplateConnector, null, function (_a, _b) {\n      var columns = _a.columns,\n          grouping = _a.grouping,\n          draftGrouping = _a.draftGrouping,\n          draggingEnabled = _a.draggingEnabled,\n          isColumnGroupingEnabled = _a.isColumnGroupingEnabled;\n      var changeColumnGrouping = _b.changeColumnGrouping,\n          draftColumnGrouping = _b.draftColumnGrouping,\n          cancelColumnGroupingDraft = _b.cancelColumnGroupingDraft;\n      return createElement(LayoutComponent, {\n        items: groupingPanelItems(columns, grouping, draftGrouping),\n        isColumnGroupingEnabled: isColumnGroupingEnabled,\n        draggingEnabled: draggingEnabled,\n        onGroup: changeColumnGrouping,\n        onGroupDraft: draftColumnGrouping,\n        onGroupDraftCancel: cancelColumnGroupingDraft,\n        itemComponent: ItemPlaceholder,\n        emptyMessageComponent: EmptyMessagePlaceholder,\n        containerComponent: Container\n      });\n    }), createElement(TemplatePlaceholder, null)));\n  };\n\n  GroupingPanelRaw.defaultProps = defaultProps$2;\n  GroupingPanelRaw.components = {\n    layoutComponent: 'Layout',\n    containerComponent: 'Container',\n    itemComponent: 'Item',\n    emptyMessageComponent: 'EmptyMessage'\n  };\n  return GroupingPanelRaw;\n}(PureComponent);\n/***\r\n * A plugin that renders the Grouping Panel in the Grid's header. This panel displays grouped\r\n * columns and allows a user to modify grouping options.Optionally, the plugin allows an end-user\r\n * to change grouped columns' sorting order and render sorting indicators.\r\n * */\n\n\nvar GroupingPanel = withComponents({\n  Layout: GroupPanelLayout\n})(GroupingPanelRaw);\n\nvar DataTypeProviderBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DataTypeProviderBase, _super);\n\n  function DataTypeProviderBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DataTypeProviderBase.prototype.render = function () {\n    var _a = this.props,\n        columnNames = _a.for,\n        Formatter = _a.formatterComponent,\n        Editor = _a.editorComponent,\n        availableFilterOperations = _a.availableFilterOperations;\n\n    var getAvailableFilterOperationsComputed = function getAvailableFilterOperationsComputed(_a) {\n      var getAvailableFilterOperations = _a.getAvailableFilterOperations;\n      return getAvailableFilterOperationsGetter(getAvailableFilterOperations, availableFilterOperations, columnNames);\n    };\n\n    return createElement(Plugin, {\n      name: \"DataTypeProvider\"\n    }, createElement(Getter, {\n      name: \"getAvailableFilterOperations\",\n      computed: getAvailableFilterOperationsComputed\n    }), Formatter ? createElement(Template, {\n      name: \"valueFormatter\",\n      predicate: function predicate(_a) {\n        var column = _a.column;\n        return columnNames.includes(column.name);\n      }\n    }, function (params) {\n      return createElement(Formatter, _assign({}, params));\n    }) : null, Editor ? createElement(Template, {\n      name: \"valueEditor\",\n      predicate: function predicate(_a) {\n        var column = _a.column;\n        return columnNames.includes(column.name);\n      }\n    }, function (params) {\n      return createElement(Editor, _assign({}, params));\n    }) : null);\n  };\n\n  return DataTypeProviderBase;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n/** A plugin that allows you to customize formatting options and editors depending on the data type. */\n\n\nvar DataTypeProvider = DataTypeProviderBase;\nvar pluginDependencies$g = [{\n  name: 'Table'\n}];\nvar defaultMessages$5 = {\n  noColumns: 'Nothing to show'\n};\n\nvar visibleTableColumnsComputed = function visibleTableColumnsComputed(_a) {\n  var tableColumns = _a.tableColumns,\n      hiddenColumnNames = _a.hiddenColumnNames;\n  return visibleTableColumns(tableColumns, hiddenColumnNames);\n};\n\nvar columnExtensionValueGetter$4 = function columnExtensionValueGetter$4(columnExtensions, defaultValue) {\n  return getColumnExtensionValueGetter(columnExtensions, 'togglingEnabled', defaultValue);\n}; // tslint:disable-next-line: max-line-length\n\n\nvar TableColumnVisibilityBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableColumnVisibilityBase, _super);\n\n  function TableColumnVisibilityBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      hiddenColumnNames: props.hiddenColumnNames || props.defaultHiddenColumnNames\n    };\n    var stateHelper = createStateHelper(_this, {\n      hiddenColumnNames: function hiddenColumnNames() {\n        var onHiddenColumnNamesChange = _this.props.onHiddenColumnNamesChange;\n        return onHiddenColumnNamesChange;\n      }\n    });\n    _this.toggleColumnVisibility = stateHelper.applyFieldReducer.bind(stateHelper, 'hiddenColumnNames', toggleColumn);\n    return _this;\n  }\n\n  TableColumnVisibilityBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.hiddenColumnNames,\n        hiddenColumnNames = _a === void 0 ? prevState.hiddenColumnNames : _a;\n    return {\n      hiddenColumnNames: hiddenColumnNames\n    };\n  };\n\n  TableColumnVisibilityBase.prototype.render = function () {\n    var _a = this.props,\n        EmptyMessage = _a.emptyMessageComponent,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages$5, messages));\n    var hiddenColumnNames = this.state.hiddenColumnNames;\n    var _b = this.props,\n        columnExtensions = _b.columnExtensions,\n        columnTogglingEnabled = _b.columnTogglingEnabled;\n    return createElement(Plugin, {\n      name: \"TableColumnVisibility\",\n      dependencies: pluginDependencies$g\n    }, createElement(Getter, {\n      name: \"hiddenColumnNames\",\n      value: hiddenColumnNames\n    }), createElement(Getter, {\n      name: \"tableColumns\",\n      computed: visibleTableColumnsComputed\n    }), createElement(Getter, {\n      name: \"isColumnTogglingEnabled\",\n      value: columnExtensionValueGetter$4(columnExtensions, columnTogglingEnabled)\n    }), createElement(Action, {\n      name: \"toggleColumnVisibility\",\n      action: this.toggleColumnVisibility\n    }), createElement(Template, {\n      name: \"table\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var tableColumns = _a.tableColumns;\n        return tableDataColumnsExist(tableColumns) ? createElement(TemplatePlaceholder, null) : createElement(EmptyMessage, _assign({\n          getMessage: getMessage\n        }, params));\n      });\n    }));\n  };\n\n  TableColumnVisibilityBase.defaultProps = {\n    defaultHiddenColumnNames: [],\n    messages: {},\n    columnTogglingEnabled: true\n  };\n  TableColumnVisibilityBase.components = {\n    emptyMessageComponent: 'EmptyMessage'\n  };\n  return TableColumnVisibilityBase;\n}(PureComponent);\n\nTableColumnVisibilityBase.components = {\n  emptyMessageComponent: 'EmptyMessage'\n};\n/* tslint:disable: max-line-length */\n\n/** A plugin that manages Grid columns' visibility. */\n\nvar TableColumnVisibility = TableColumnVisibilityBase;\n/* tslint:enable: max-line-length */\n\nvar ToolbarBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ToolbarBase, _super);\n\n  function ToolbarBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolbarBase.prototype.render = function () {\n    var _a = this.props,\n        Root = _a.rootComponent,\n        FlexibleSpaceComponent = _a.flexibleSpaceComponent;\n    return createElement(Plugin, {\n      name: \"Toolbar\"\n    }, createElement(Template, {\n      name: \"header\"\n    }, createElement(Root, null, createElement(TemplatePlaceholder, {\n      name: \"toolbarContent\"\n    })), createElement(TemplatePlaceholder, null)), createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(FlexibleSpaceComponent, null)));\n  };\n\n  ToolbarBase.components = {\n    rootComponent: 'Root',\n    flexibleSpaceComponent: 'FlexibleSpace'\n  };\n  return ToolbarBase;\n}(PureComponent);\n/** A plugin that renders the Grid toolbar. */\n\n\nvar Toolbar = ToolbarBase;\n\nvar TreeDataStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TreeDataStateBase, _super);\n\n  function TreeDataStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds\n    };\n    var stateHelper = createStateHelper(_this, {\n      expandedRowIds: function expandedRowIds() {\n        var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;\n        return onExpandedRowIdsChange;\n      }\n    });\n    _this.toggleRowExpanded = stateHelper.applyFieldReducer.bind(stateHelper, 'expandedRowIds', toggleRowExpanded);\n    return _this;\n  }\n\n  TreeDataStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.expandedRowIds,\n        expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;\n    return {\n      expandedRowIds: expandedRowIds\n    };\n  };\n\n  TreeDataStateBase.prototype.render = function () {\n    var expandedRowIds = this.state.expandedRowIds;\n    return createElement(Plugin, {\n      name: \"TreeDataState\"\n    }, createElement(Getter, {\n      name: \"expandedRowIds\",\n      value: expandedRowIds\n    }), ' ', createElement(Action, {\n      name: \"toggleRowExpanded\",\n      action: this.toggleRowExpanded\n    }));\n  };\n\n  TreeDataStateBase.defaultProps = {\n    defaultExpandedRowIds: []\n  };\n  return TreeDataStateBase;\n}(PureComponent);\n/** A plugin that manages the expanded state for tree rows. */\n\n\nvar TreeDataState = TreeDataStateBase;\nvar pluginDependencies$h = [{\n  name: 'TreeDataState'\n}];\n\nvar expandedTreeRowsComputed = function expandedTreeRowsComputed(_a) {\n  var rows = _a.rows,\n      getRowId = _a.getRowId,\n      expandedRowIds = _a.expandedRowIds;\n  return expandedTreeRows(rows, getRowId, expandedRowIds);\n};\n\nvar getRowIdComputed$1 = function getRowIdComputed$1(_a) {\n  var getRowId = _a.getRowId,\n      rows = _a.rows;\n  return customTreeRowIdGetter(getRowId, rows);\n};\n\nvar getRowLevelKeyComputed = function getRowLevelKeyComputed(_a) {\n  var getRowLevelKey = _a.getRowLevelKey,\n      rows = _a.rows;\n  return customTreeRowLevelKeyGetter(getRowLevelKey, rows);\n};\n\nvar isTreeRowLeafComputed = function isTreeRowLeafComputed(_a) {\n  var rows = _a.rows;\n  return isTreeRowLeafGetter(rows);\n};\n\nvar getTreeRowLevelComputed = function getTreeRowLevelComputed(_a) {\n  var rows = _a.rows;\n  return getTreeRowLevelGetter(rows);\n};\n\nvar collapsedTreeRowsGetterComputed = function collapsedTreeRowsGetterComputed(_a) {\n  var rows = _a.rows,\n      getCollapsedRows = _a.getCollapsedRows;\n  return collapsedTreeRowsGetter(getCollapsedRows, rows);\n};\n\nvar unwrappedTreeRowsComputed = function unwrappedTreeRowsComputed(_a) {\n  var rows = _a.rows;\n  return unwrappedCustomTreeRows(rows);\n};\n\nvar CustomTreeDataBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(CustomTreeDataBase, _super);\n\n  function CustomTreeDataBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CustomTreeDataBase.prototype.render = function () {\n    var getChildRows = this.props.getChildRows;\n\n    var treeRowsComputed = function treeRowsComputed(_a) {\n      var rows = _a.rows;\n      return customTreeRowsWithMeta(rows, getChildRows);\n    };\n\n    return createElement(Plugin, {\n      name: \"CustomTreeData\",\n      dependencies: pluginDependencies$h\n    }, createElement(Getter, {\n      name: \"rows\",\n      computed: treeRowsComputed\n    }), createElement(Getter, {\n      name: \"getRowId\",\n      computed: getRowIdComputed$1\n    }), createElement(Getter, {\n      name: \"getRowLevelKey\",\n      computed: getRowLevelKeyComputed\n    }), createElement(Getter, {\n      name: \"isTreeRowLeaf\",\n      computed: isTreeRowLeafComputed\n    }), createElement(Getter, {\n      name: \"getTreeRowLevel\",\n      computed: getTreeRowLevelComputed\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: expandedTreeRowsComputed\n    }), createElement(Getter, {\n      name: \"getCollapsedRows\",\n      computed: collapsedTreeRowsGetterComputed\n    }), createElement(Getter, {\n      name: \"rows\",\n      computed: unwrappedTreeRowsComputed\n    }));\n  };\n\n  return CustomTreeDataBase;\n}(PureComponent);\n/***\r\n * A plugin that converts custom formatted tree data to a supported format and performs\r\n * local row expanding/collapsing.\r\n * */\n\n\nvar CustomTreeData = CustomTreeDataBase;\n\nvar TableTreeColumnBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableTreeColumnBase, _super);\n\n  function TableTreeColumnBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableTreeColumnBase.prototype.render = function () {\n    var _a = this.props,\n        forColumnName = _a.for,\n        showSelectionControls = _a.showSelectionControls,\n        showSelectAll = _a.showSelectAll,\n        Indent = _a.indentComponent,\n        ExpandButton = _a.expandButtonComponent,\n        Checkbox = _a.checkboxComponent,\n        Content = _a.contentComponent,\n        Cell = _a.cellComponent;\n    return createElement(Plugin, {\n      name: \"TableTreeColumn\",\n      dependencies: [{\n        name: 'DataTypeProvider',\n        optional: true\n      }, {\n        name: 'TreeDataState'\n      }, {\n        name: 'SelectionState',\n        optional: !showSelectionControls\n      }, {\n        name: 'IntegratedSelection',\n        optional: !showSelectAll\n      }, {\n        name: 'Table'\n      }, {\n        name: 'TableHeaderRow',\n        optional: true\n      }]\n    }, createElement(Getter, {\n      name: \"tableTreeColumnName\",\n      value: forColumnName\n    }), createElement(Template, {\n      name: \"tableHeaderCellBefore\",\n      predicate: function predicate(_a) {\n        var column = _a.column;\n        return column.name === forColumnName;\n      }\n    }, createElement(ExpandButton, {\n      visible: false,\n      expanded: false,\n      onToggle: function onToggle() {}\n    }), showSelectionControls && showSelectAll && createElement(TemplateConnector, null, function (_a, _b) {\n      var selectAllAvailable = _a.selectAllAvailable,\n          allSelected = _a.allSelected,\n          someSelected = _a.someSelected;\n      var toggleSelectAll = _b.toggleSelectAll;\n      return createElement(Checkbox, {\n        disabled: !selectAllAvailable,\n        checked: allSelected,\n        indeterminate: someSelected,\n        onChange: toggleSelectAll\n      });\n    })), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isTreeTableCell(tableRow, tableColumn, forColumnName);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var getCollapsedRows = _a.getCollapsedRows,\n            expandedRowIds = _a.expandedRowIds,\n            selection = _a.selection,\n            isTreeRowLeaf = _a.isTreeRowLeaf,\n            getTreeRowLevel = _a.getTreeRowLevel,\n            getCellValue = _a.getCellValue;\n        var toggleRowExpanded = _b.toggleRowExpanded,\n            toggleSelection = _b.toggleSelection;\n        var _c = params.tableRow,\n            row = _c.row,\n            rowId = _c.rowId;\n        var columnName = params.tableColumn.column.name;\n        var value = getCellValue(row, columnName);\n        var collapsedRows = getCollapsedRows(row);\n        return createElement(TemplatePlaceholder, {\n          name: \"valueFormatter\",\n          params: {\n            value: value,\n            row: row,\n            column: params.tableColumn.column\n          }\n        }, function (content) {\n          return createElement(Cell, _assign({}, params, {\n            row: row,\n            column: params.tableColumn.column,\n            value: value\n          }), createElement(Indent, {\n            level: getTreeRowLevel(row)\n          }), createElement(ExpandButton, {\n            visible: collapsedRows ? !!collapsedRows.length : !isTreeRowLeaf(row),\n            expanded: expandedRowIds.indexOf(rowId) > -1,\n            onToggle: function onToggle() {\n              return toggleRowExpanded({\n                rowId: rowId\n              });\n            }\n          }), showSelectionControls && createElement(Checkbox, {\n            disabled: false,\n            checked: selection.indexOf(rowId) > -1,\n            indeterminate: false,\n            onChange: function onChange() {\n              return toggleSelection({\n                rowIds: [rowId]\n              });\n            }\n          }), createElement(Content, null, content || value));\n        });\n      });\n    }));\n  };\n\n  TableTreeColumnBase.defaultProps = {\n    showSelectionControls: false,\n    showSelectAll: false\n  };\n  TableTreeColumnBase.components = {\n    cellComponent: 'Cell',\n    contentComponent: 'Content',\n    indentComponent: 'Indent',\n    expandButtonComponent: 'ExpandButton',\n    checkboxComponent: 'Checkbox'\n  };\n  return TableTreeColumnBase;\n}(PureComponent);\n/** A plugin that renders a table column with a toggle button and sorting indicators. */\n\n\nvar TableTreeColumn = TableTreeColumnBase;\n\nvar SearchStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SearchStateBase, _super);\n\n  function SearchStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      value: props.value || props.defaultValue\n    };\n    var stateHelper = createStateHelper(_this, {\n      value: function value() {\n        var onValueChange = _this.props.onValueChange;\n        return onValueChange;\n      }\n    });\n    _this.changeValue = stateHelper.applyFieldReducer.bind(stateHelper, 'value', changeSearchValue);\n    return _this;\n  }\n\n  SearchStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.value,\n        value = _a === void 0 ? prevState.value : _a;\n    return {\n      value: value\n    };\n  };\n\n  SearchStateBase.prototype.render = function () {\n    var value = this.state.value;\n\n    var filterExpressionComputed = function filterExpressionComputed(_a) {\n      var filterExpression = _a.filterExpression,\n          columns = _a.columns;\n      return searchFilterExpression(value, columns, filterExpression);\n    };\n\n    return createElement(Plugin, {\n      name: \"SearchState\"\n    }, createElement(Getter, {\n      name: \"filterExpression\",\n      computed: filterExpressionComputed\n    }), createElement(Getter, {\n      name: \"searchValue\",\n      value: value\n    }), createElement(Action, {\n      name: \"changeSearchValue\",\n      action: this.changeValue\n    }));\n  };\n\n  SearchStateBase.defaultProps = {\n    defaultValue: ''\n  };\n  return SearchStateBase;\n}(PureComponent);\n/** A plugin that manages the search state. */\n\n\nvar SearchState = SearchStateBase;\nvar pluginDependencies$i = [{\n  name: 'Toolbar'\n}, {\n  name: 'SearchState'\n}];\nvar defaultMessages$6 = {\n  searchPlaceholder: 'Search...'\n};\n\nvar SearchPanelBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SearchPanelBase, _super);\n\n  function SearchPanelBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SearchPanelBase.prototype.render = function () {\n    var _a = this.props,\n        Input = _a.inputComponent,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages$6, messages));\n    return createElement(Plugin, {\n      name: \"SearchPanel\",\n      dependencies: pluginDependencies$i\n    }, createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a, _b) {\n      var searchValue = _a.searchValue;\n      var changeSearchValue = _b.changeSearchValue;\n      return createElement(Input, {\n        value: searchValue,\n        onValueChange: changeSearchValue,\n        getMessage: getMessage\n      });\n    })));\n  };\n\n  SearchPanelBase.defaultProps = {\n    messages: {}\n  };\n  SearchPanelBase.components = {\n    inputComponent: 'Input'\n  };\n  return SearchPanelBase;\n}(PureComponent);\n/** A plugin that renders the Search Panel. */\n\n\nvar SearchPanel = SearchPanelBase;\n\nvar tableHeaderRowsComputed$2 = function tableHeaderRowsComputed$2(_a) {\n  var tableHeaderRows = _a.tableHeaderRows;\n  return tableHeaderRowsWithFixed(tableHeaderRows);\n};\n\nvar tableHeaderColumnChainsComputed = function tableHeaderColumnChainsComputed(_a) {\n  var tableColumns = _a.tableColumns,\n      tableHeaderRows = _a.tableHeaderRows,\n      tableHeaderColumnChains = _a.tableHeaderColumnChains;\n  return tableHeaderColumnChainsWithFixed(tableHeaderColumnChains, tableHeaderRows, tableColumns);\n};\n\nvar CellPlaceholder$2 = function CellPlaceholder$2(props) {\n  return createElement(TemplatePlaceholder, {\n    params: props\n  });\n};\n\nvar pluginDependencies$j = [{\n  name: 'Table'\n}, {\n  name: 'TableBandHeader',\n  optional: true\n}, {\n  name: 'TableColumnReordering',\n  optional: true\n}, {\n  name: 'TableEditColumn',\n  optional: true\n}, {\n  name: 'TableEditRow',\n  optional: true\n}, {\n  name: 'TableFilterRow',\n  optional: true\n}, {\n  name: 'TableHeaderRow',\n  optional: true\n}, {\n  name: 'TableSelection',\n  optional: true\n}, {\n  name: 'TableSummaryRow',\n  optional: true\n}, {\n  name: 'TableTreeColumn',\n  optional: true\n}]; // tslint:disable-next-line: max-line-length\n\nvar TableFixedColumnsBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableFixedColumnsBase, _super);\n\n  function TableFixedColumnsBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      tableColumnDimensions: {}\n    };\n    return _this;\n  }\n\n  TableFixedColumnsBase.prototype.handleListenerSizeChange = function (key, width) {\n    this.setState(function (state) {\n      var _a;\n\n      return {\n        tableColumnDimensions: _assign({}, state.tableColumnDimensions, (_a = {}, _a[key] = width, _a))\n      };\n    });\n  };\n\n  TableFixedColumnsBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        Cell = _a.cellComponent,\n        ListenerRow = _a.listenerRowComponent,\n        ListenerCell = _a.listenerCellComponent;\n    var leftColumns = this.props.leftColumns;\n    var rightColumns = this.props.rightColumns;\n\n    var tableColumnsComputed = function tableColumnsComputed(_a) {\n      var tableColumns = _a.tableColumns;\n      return tableColumnsWithFixed(tableColumns, leftColumns, rightColumns);\n    };\n\n    return createElement(Plugin, {\n      name: \"TableFixedColumns\",\n      dependencies: pluginDependencies$j\n    }, createElement(Getter, {\n      name: \"tableHeaderRows\",\n      computed: tableHeaderRowsComputed$2\n    }), createElement(Getter, {\n      name: \"tableColumns\",\n      computed: tableColumnsComputed\n    }), createElement(Getter, {\n      name: \"tableHeaderColumnChains\",\n      computed: tableHeaderColumnChainsComputed\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableColumn = _a.tableColumn;\n        return !!tableColumn.fixed;\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var tableColumns = _a.tableColumns,\n            tableHeaderColumnChains = _a.tableHeaderColumnChains;\n        var tableColumnDimensions = _this.state.tableColumnDimensions;\n        var fixedColumnProps = calculateFixedColumnProps(params, {\n          leftColumns: leftColumns,\n          rightColumns: rightColumns\n        }, tableColumns, tableColumnDimensions, tableHeaderColumnChains);\n        return createElement(Cell, _assign({}, params, fixedColumnProps, {\n          component: CellPlaceholder$2\n        }));\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isFixedTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(ListenerRow, _assign({}, params));\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isFixedTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(ListenerCell, _assign({}, params, {\n        listen: !!params.tableColumn.fixed,\n        onSizeChange: function onSizeChange(_a) {\n          var width = _a.width;\n          return _this.handleListenerSizeChange(params.tableColumn.key, width);\n        }\n      }));\n    }));\n  };\n\n  TableFixedColumnsBase.components = {\n    cellComponent: 'Cell',\n    listenerRowComponent: 'ListenerRow',\n    listenerCellComponent: 'ListenerCell'\n  };\n  TableFixedColumnsBase.defaultProps = {\n    leftColumns: [],\n    rightColumns: []\n  };\n  return TableFixedColumnsBase;\n}(PureComponent);\n/** A plugin that enables you to fix columns to the left and right sides of the grid. */\n\n\nvar TableFixedColumns = TableFixedColumnsBase;\n\nvar SummaryStateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SummaryStateBase, _super);\n\n  function SummaryStateBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SummaryStateBase.prototype.render = function () {\n    var _a = this.props,\n        totalItems = _a.totalItems,\n        groupItems = _a.groupItems,\n        treeItems = _a.treeItems;\n    return createElement(Plugin, {\n      name: \"SummaryState\"\n    }, createElement(Getter, {\n      name: \"totalSummaryItems\",\n      value: totalItems\n    }), createElement(Getter, {\n      name: \"groupSummaryItems\",\n      value: groupItems\n    }), createElement(Getter, {\n      name: \"treeSummaryItems\",\n      value: treeItems\n    }));\n  };\n\n  return SummaryStateBase;\n}(PureComponent);\n/** A plugin that provides items for total, group, and tree summaries. */\n\n\nvar SummaryState = SummaryStateBase;\nvar pluginDependencies$k = [{\n  name: 'SummaryState'\n}];\n\nvar IntegratedSummaryBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(IntegratedSummaryBase, _super);\n\n  function IntegratedSummaryBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  IntegratedSummaryBase.prototype.render = function () {\n    var calculator = this.props.calculator;\n\n    var totalSummaryValuesComputed = function totalSummaryValuesComputed(_a) {\n      var rows = _a.rows,\n          totalSummaryItems = _a.totalSummaryItems,\n          getCellValue = _a.getCellValue,\n          getRowLevelKey = _a.getRowLevelKey,\n          isGroupRow = _a.isGroupRow,\n          getCollapsedRows = _a.getCollapsedRows;\n      return totalSummaryValues(rows, totalSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator);\n    };\n\n    var groupSummaryValuesComputed = function groupSummaryValuesComputed(_a) {\n      var rows = _a.rows,\n          groupSummaryItems = _a.groupSummaryItems,\n          getCellValue = _a.getCellValue,\n          getRowLevelKey = _a.getRowLevelKey,\n          isGroupRow = _a.isGroupRow;\n      return groupSummaryValues(rows, groupSummaryItems, getCellValue, getRowLevelKey, isGroupRow, calculator);\n    };\n\n    var treeSummaryValuesComputed = function treeSummaryValuesComputed(_a) {\n      var rows = _a.rows,\n          treeSummaryItems = _a.treeSummaryItems,\n          getCellValue = _a.getCellValue,\n          getRowLevelKey = _a.getRowLevelKey,\n          isGroupRow = _a.isGroupRow,\n          getRowId = _a.getRowId;\n      return treeSummaryValues(rows, treeSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator);\n    };\n\n    return createElement(Plugin, {\n      name: \"IntegratedSummary\",\n      dependencies: pluginDependencies$k\n    }, createElement(Getter, {\n      name: \"totalSummaryValues\",\n      computed: totalSummaryValuesComputed\n    }), createElement(Getter, {\n      name: \"groupSummaryValues\",\n      computed: groupSummaryValuesComputed\n    }), createElement(Getter, {\n      name: \"treeSummaryValues\",\n      computed: treeSummaryValuesComputed\n    }));\n  };\n\n  IntegratedSummaryBase.defaultCalculator = defaultSummaryCalculator;\n  return IntegratedSummaryBase;\n}(PureComponent);\n/** A plugin that performs a built-in data summary calculation. */\n\n\nvar IntegratedSummary = IntegratedSummaryBase;\nvar pluginDependencies$l = [{\n  name: 'SummaryState'\n}];\n\nvar CustomSummaryBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(CustomSummaryBase, _super);\n\n  function CustomSummaryBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  CustomSummaryBase.prototype.render = function () {\n    var _a = this.props,\n        totalValues = _a.totalValues,\n        groupValues = _a.groupValues,\n        treeValues = _a.treeValues;\n    return createElement(Plugin, {\n      name: \"CustomSummary\",\n      dependencies: pluginDependencies$l\n    }, createElement(Getter, {\n      name: \"totalSummaryValues\",\n      value: totalValues\n    }), createElement(Getter, {\n      name: \"groupSummaryValues\",\n      value: groupValues\n    }), createElement(Getter, {\n      name: \"treeSummaryValues\",\n      value: treeValues\n    }));\n  };\n\n  return CustomSummaryBase;\n}(PureComponent);\n/** A plugin that allows you to calculate a custom summary. */\n\n\nvar CustomSummary = CustomSummaryBase;\nvar dependencies$1 = [{\n  name: 'DataTypeProvider',\n  optional: true\n}, {\n  name: 'SummaryState'\n}, {\n  name: 'CustomSummary',\n  optional: true\n}, {\n  name: 'IntegratedSummary',\n  optional: true\n}, {\n  name: 'Table'\n}, {\n  name: 'TableTreeColumn',\n  optional: true\n}];\nvar defaultMessages$7 = {\n  sum: 'Sum',\n  min: 'Min',\n  max: 'Max',\n  avg: 'Avg',\n  count: 'Count'\n};\n\nvar tableBodyRowsComputed$2 = function tableBodyRowsComputed$2(_a) {\n  var tableBodyRows = _a.tableBodyRows,\n      getRowLevelKey = _a.getRowLevelKey,\n      isGroupRow = _a.isGroupRow,\n      getRowId = _a.getRowId;\n  return tableRowsWithSummaries(tableBodyRows, getRowLevelKey, isGroupRow, getRowId);\n};\n\nvar tableFooterRowsComputed = function tableFooterRowsComputed(_a) {\n  var tableFooterRows = _a.tableFooterRows;\n  return tableRowsWithTotalSummaries(tableFooterRows);\n};\n\nvar defaultTypelessSummaries = ['count'];\n\nvar TableSummaryRowBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableSummaryRowBase, _super);\n\n  function TableSummaryRowBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableSummaryRowBase.prototype.renderContent = function (column, columnSummaries) {\n    var _a = this.props,\n        formatlessSummaryTypes = _a.formatlessSummaryTypes,\n        Item = _a.itemComponent,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign({}, defaultMessages$7, messages));\n\n    var SummaryItem = function SummaryItem(_a) {\n      var summary = _a.summary,\n          children = _a.children;\n      return createElement(Item, {\n        getMessage: getMessage,\n        type: summary.type,\n        value: summary.value\n      }, children || String(summary.value));\n    };\n\n    return createElement(Fragment, null, columnSummaries.map(function (summary) {\n      if (summary.value === null || formatlessSummaryTypes.includes(summary.type) || defaultTypelessSummaries.includes(summary.type)) {\n        return createElement(SummaryItem, {\n          key: summary.type,\n          summary: summary\n        });\n      }\n\n      return createElement(TemplatePlaceholder, {\n        key: summary.type,\n        name: \"valueFormatter\",\n        params: {\n          column: column,\n          value: summary.value\n        }\n      }, function (content) {\n        return createElement(SummaryItem, {\n          summary: summary\n        }, content);\n      });\n    }));\n  };\n\n  TableSummaryRowBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        TotalRow = _a.totalRowComponent,\n        GroupRow = _a.groupRowComponent,\n        TreeRow = _a.treeRowComponent,\n        TotalCell = _a.totalCellComponent,\n        GroupCell = _a.groupCellComponent,\n        TreeCell = _a.treeCellComponent,\n        TreeColumnCell = _a.treeColumnCellComponent,\n        TreeColumnContent = _a.treeColumnContentComponent,\n        TreeColumnIndent = _a.treeColumnIndentComponent;\n    return createElement(Plugin, {\n      name: \"TableSummaryRow\",\n      dependencies: dependencies$1\n    }, createElement(Getter, {\n      name: \"tableBodyRows\",\n      computed: tableBodyRowsComputed$2\n    }), createElement(Getter, {\n      name: \"tableFooterRows\",\n      computed: tableFooterRowsComputed\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isTotalSummaryTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var totalSummaryItems = _a.totalSummaryItems,\n            totalSummaryValues = _a.totalSummaryValues;\n        var columnSummaries = getColumnSummaries(totalSummaryItems, params.tableColumn.column.name, totalSummaryValues);\n        return createElement(TotalCell, _assign({}, params, {\n          column: params.tableColumn.column\n        }), _this.renderContent(params.tableColumn.column, columnSummaries));\n      });\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isGroupSummaryTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var groupSummaryItems = _a.groupSummaryItems,\n            groupSummaryValues = _a.groupSummaryValues;\n        var columnSummaries = getColumnSummaries(groupSummaryItems, params.tableColumn.column.name, groupSummaryValues[params.tableRow.row.compoundKey]);\n        return createElement(GroupCell, _assign({}, params, {\n          column: params.tableColumn.column\n        }), _this.renderContent(params.tableColumn.column, columnSummaries));\n      });\n    }), createElement(Template, {\n      name: \"tableCell\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow,\n            tableColumn = _a.tableColumn;\n        return isTreeSummaryTableCell(tableRow, tableColumn);\n      }\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var treeSummaryItems = _a.treeSummaryItems,\n            treeSummaryValues = _a.treeSummaryValues,\n            tableTreeColumnName = _a.tableTreeColumnName,\n            getRowId = _a.getRowId,\n            getTreeRowLevel = _a.getTreeRowLevel;\n        var columnSummaries = getColumnSummaries(treeSummaryItems, params.tableColumn.column.name, treeSummaryValues[getRowId(params.tableRow.row)]);\n\n        if (tableTreeColumnName === params.tableColumn.column.name) {\n          return createElement(TreeColumnCell, _assign({}, params, {\n            column: params.tableColumn.column\n          }), createElement(TreeColumnIndent, {\n            level: getTreeRowLevel(params.tableRow.row)\n          }), createElement(TreeColumnContent, null, _this.renderContent(params.tableColumn.column, columnSummaries)));\n        }\n\n        return createElement(TreeCell, _assign({}, params, {\n          column: params.tableColumn.column\n        }), _this.renderContent(params.tableColumn.column, columnSummaries));\n      });\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isTotalSummaryTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(TotalRow, _assign({}, params));\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isGroupSummaryTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(GroupRow, _assign({}, params));\n    }), createElement(Template, {\n      name: \"tableRow\",\n      predicate: function predicate(_a) {\n        var tableRow = _a.tableRow;\n        return !!isTreeSummaryTableRow(tableRow);\n      }\n    }, function (params) {\n      return createElement(TreeRow, _assign({}, params));\n    }));\n  };\n\n  TableSummaryRowBase.TREE_ROW_TYPE = TABLE_TREE_SUMMARY_TYPE;\n  TableSummaryRowBase.GROUP_ROW_TYPE = TABLE_GROUP_SUMMARY_TYPE;\n  TableSummaryRowBase.TOTAL_ROW_TYPE = TABLE_TOTAL_SUMMARY_TYPE;\n  TableSummaryRowBase.defaultProps = {\n    formatlessSummaryTypes: [],\n    messages: {}\n  };\n  TableSummaryRowBase.components = {\n    totalRowComponent: 'TotalRow',\n    groupRowComponent: 'GroupRow',\n    treeRowComponent: 'TreeRow',\n    totalCellComponent: 'TotalCell',\n    groupCellComponent: 'GroupCell',\n    treeCellComponent: 'TreeCell',\n    treeColumnCellComponent: 'TableTreeCell',\n    treeColumnContentComponent: 'TableTreeContent',\n    treeColumnIndentComponent: 'TableTreeIndent',\n    itemComponent: 'Item'\n  };\n  return TableSummaryRowBase;\n}(PureComponent);\n/** A plugin that renders table rows that display a total, group, and tree summary. */\n\n\nvar TableSummaryRow = TableSummaryRowBase;\n/* globals requestAnimationFrame cancelAnimationFrame */\n\nvar TableLayoutBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TableLayoutBase, _super);\n\n  function TableLayoutBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.savedOffsetWidth = -1;\n    _this.raf = -1;\n    _this.state = {\n      animationState: new Map()\n    };\n    _this.animations = new Map();\n    _this.savedScrolldWidth = {};\n    _this.tableRef = createRef();\n    return _this;\n  }\n\n  TableLayoutBase.prototype.componentDidUpdate = function (prevProps) {\n    var columns = this.props.columns;\n    var prevColumns = prevProps.columns;\n    var tableWidth = this.getTableWidth(prevColumns, columns);\n    this.animations = getAnimations(prevColumns, columns, tableWidth, this.animations);\n    cancelAnimationFrame(this.raf);\n    this.raf = requestAnimationFrame(this.processAnimationFrame.bind(this));\n  };\n\n  TableLayoutBase.prototype.getTableWidth = function (prevColumns, columns) {\n    var _a = this.tableRef.current,\n        offsetWidth = _a.offsetWidth,\n        scrollWidth = _a.scrollWidth;\n    var animationState = this.state.animationState;\n    var widthChanged = this.savedOffsetWidth !== offsetWidth || !this.savedScrolldWidth[columns.length];\n    var columnCountChanged = columns.length !== prevColumns.length;\n\n    if (columnCountChanged || widthChanged && !animationState.size) {\n      this.savedScrolldWidth = {};\n      this.savedScrolldWidth[columns.length] = scrollWidth;\n      this.savedOffsetWidth = offsetWidth;\n    }\n\n    return this.savedScrolldWidth[columns.length];\n  };\n\n  TableLayoutBase.prototype.getColumns = function () {\n    var columns = this.props.columns;\n    var animationState = this.state.animationState;\n    var result = columns;\n    var isFixedWidth = columns.filter(function (column) {\n      return column.width === undefined;\n    }).length === 0;\n\n    if (isFixedWidth) {\n      result = __spread(result, [{\n        key: TABLE_FLEX_TYPE.toString(),\n        type: TABLE_FLEX_TYPE\n      }]);\n    }\n\n    if (animationState.size) {\n      result = result.map(function (column) {\n        return animationState.has(column.key) ? _assign({}, column, {\n          animationState: animationState.get(column.key)\n        }) : column;\n      });\n    }\n\n    return result;\n  };\n\n  TableLayoutBase.prototype.processAnimationFrame = function () {\n    var animationComponentState = this.state.animationState;\n    this.animations = filterActiveAnimations(this.animations);\n\n    if (!this.animations.size) {\n      if (animationComponentState.size) {\n        this.setState({\n          animationState: new Map()\n        });\n      }\n\n      return;\n    }\n\n    var animationState = evalAnimations(this.animations);\n    this.setState({\n      animationState: animationState\n    });\n  };\n\n  TableLayoutBase.prototype.render = function () {\n    var _a = this.props,\n        Layout = _a.layoutComponent,\n        minColumnWidth = _a.minColumnWidth,\n        restProps = __rest(_a, [\"layoutComponent\", \"minColumnWidth\"]);\n\n    var columns = this.getColumns();\n    var minWidth = columns.map(function (column) {\n      return column.width || (column.type === TABLE_FLEX_TYPE ? 0 : minColumnWidth);\n    }).reduce(function (acc, width) {\n      return acc + width;\n    }, 0);\n    return createElement(Layout, _assign({}, restProps, {\n      tableRef: this.tableRef,\n      columns: columns,\n      minWidth: minWidth,\n      minColumnWidth: minColumnWidth\n    }));\n  };\n\n  return TableLayoutBase;\n}(PureComponent);\n/** @internal */\n\n\nvar TableLayout = TableLayoutBase;\n/** @internal */\n\nvar ColumnGroup =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ColumnGroup, _super);\n\n  function ColumnGroup() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ColumnGroup.prototype.render = function () {\n    var columns = this.props.columns;\n    return createElement(\"colgroup\", null, columns.map(function (_a) {\n      var key = _a.key,\n          width = _a.width;\n      return createElement(\"col\", {\n        key: key,\n        style: width !== undefined ? {\n          width: width + \"px\"\n        } : undefined\n      });\n    }));\n  };\n\n  return ColumnGroup;\n}(PureComponent);\n\nvar AUTO_HEIGHT = 'auto';\nvar defaultProps$3 = {\n  headerRows: [],\n  footerRows: [],\n  headComponent: function headComponent() {\n    return null;\n  },\n  headTableComponent: function headTableComponent() {\n    return null;\n  },\n  footerComponent: function footerComponent() {\n    return null;\n  },\n  footerTableComponent: function footerTableComponent() {\n    return null;\n  }\n};\n/** @internal */\n// tslint:disable-next-line: max-line-length\n\nvar VirtualTableLayout =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(VirtualTableLayout, _super);\n\n  function VirtualTableLayout(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.isEdgeBrowser = false;\n    _this.state = {\n      bodyHeight: 0,\n      headerHeight: 0,\n      footerHeight: 0,\n      rowHeights: new Map(),\n      viewportTop: 0,\n      viewportLeft: 0,\n      width: 800,\n      height: 600\n    };\n    var headerHeight = props.headerRows.reduce(function (acc, row) {\n      return acc + _this.getRowHeight(row);\n    }, 0);\n    var footerHeight = props.footerRows.reduce(function (acc, row) {\n      return acc + _this.getRowHeight(row);\n    }, 0);\n    _this.state = _assign({\n      headerHeight: headerHeight,\n      footerHeight: footerHeight\n    }, _this.state);\n    _this.rowRefs = new Map();\n    _this.blockRefs = new Map();\n    _this.registerRowRef = _this.registerRowRef.bind(_this);\n    _this.getRowHeight = _this.getRowHeight.bind(_this);\n    _this.updateViewport = _this.updateViewport.bind(_this);\n    _this.handleContainerSizeChange = _this.handleContainerSizeChange.bind(_this);\n    _this.getColumnWidthGetter = memoize(function (tableColumns, tableWidth, minColumnWidth) {\n      return getColumnWidthGetter(tableColumns, tableWidth, minColumnWidth);\n    });\n    return _this;\n  }\n\n  VirtualTableLayout.prototype.componentDidMount = function () {\n    this.isEdgeBrowser = isEdgeBrowser();\n    this.storeRowHeights();\n    this.storeBloksHeights();\n  };\n\n  VirtualTableLayout.prototype.componentDidUpdate = function () {\n    this.storeRowHeights();\n    this.storeBloksHeights();\n  };\n\n  VirtualTableLayout.getDerivedStateFromProps = function (nextProps, prevState) {\n    var prevRowHeight = prevState.rowHeights;\n\n    var rowHeights = __spread(nextProps.headerRows, nextProps.bodyRows, nextProps.footerRows).reduce(function (acc, row) {\n      var rowHeight = prevRowHeight.get(row.key);\n\n      if (rowHeight !== undefined) {\n        acc.set(row.key, rowHeight);\n      }\n\n      return acc;\n    }, new Map());\n\n    return {\n      rowHeights: rowHeights\n    };\n  };\n\n  VirtualTableLayout.prototype.getRowHeight = function (row) {\n    var rowHeights = this.state.rowHeights;\n    var estimatedRowHeight = this.props.estimatedRowHeight;\n    var storedHeight = rowHeights.get(row.key);\n    if (storedHeight !== undefined) return storedHeight;\n    if (row.height) return row.height;\n    return estimatedRowHeight;\n  };\n\n  VirtualTableLayout.prototype.storeRowHeights = function () {\n    var _this = this;\n\n    var rowsWithChangedHeights = Array.from(this.rowRefs.entries()) // eslint-disable-next-line react/no-find-dom-node\n    .map(function (_a) {\n      var _b = __read(_a, 2),\n          row = _b[0],\n          ref = _b[1];\n\n      return [row, findDOMNode(ref)];\n    }).filter(function (_a) {\n      var _b = __read(_a, 2),\n          node = _b[1];\n\n      return !!node;\n    }).map(function (_a) {\n      var _b = __read(_a, 2),\n          row = _b[0],\n          node = _b[1];\n\n      return [row, node.getBoundingClientRect().height];\n    }).filter(function (_a) {\n      var _b = __read(_a, 1),\n          row = _b[0];\n\n      return row.type !== TABLE_STUB_TYPE;\n    }).filter(function (_a) {\n      var _b = __read(_a, 2),\n          row = _b[0],\n          height = _b[1];\n\n      return height !== _this.getRowHeight(row);\n    });\n\n    if (rowsWithChangedHeights.length) {\n      var rowHeights_1 = this.state.rowHeights;\n      rowsWithChangedHeights.forEach(function (_a) {\n        var _b = __read(_a, 2),\n            row = _b[0],\n            height = _b[1];\n\n        return rowHeights_1.set(row.key, height);\n      });\n      this.setState({\n        rowHeights: rowHeights_1\n      });\n    }\n  };\n\n  VirtualTableLayout.prototype.storeBloksHeights = function () {\n    var _this = this;\n\n    var getBlockHeight = function getBlockHeight(blockName) {\n      return _this.blockRefs.get(blockName) ? findDOMNode(_this.blockRefs.get(blockName)).getBoundingClientRect().height : 0;\n    };\n\n    var headerHeight = getBlockHeight('header');\n    var bodyHeight = getBlockHeight('body');\n    var footerHeight = getBlockHeight('footer');\n    var _a = this.state,\n        prevHeaderHeight = _a.headerHeight,\n        prevBodyHeight = _a.bodyHeight,\n        prevFooterHeight = _a.footerHeight;\n\n    if (prevHeaderHeight !== headerHeight || prevBodyHeight !== bodyHeight || prevFooterHeight !== footerHeight) {\n      this.setState({\n        headerHeight: headerHeight,\n        bodyHeight: bodyHeight,\n        footerHeight: footerHeight\n      });\n    }\n  };\n\n  VirtualTableLayout.prototype.registerRowRef = function (row, ref) {\n    if (ref === null) {\n      this.rowRefs.delete(row);\n    } else {\n      this.rowRefs.set(row, ref);\n    }\n  };\n\n  VirtualTableLayout.prototype.registerBlockRef = function (name, ref) {\n    if (ref === null) {\n      this.blockRefs.delete(name);\n    } else {\n      this.blockRefs.set(name, ref);\n    }\n  };\n\n  VirtualTableLayout.prototype.shouldSkipScrollEvent = function (e) {\n    var node = e.target; // NOTE: prevent nested scroll to update viewport\n\n    if (node !== e.currentTarget) {\n      return true;\n    } // NOTE: prevent iOS to flicker in bounces and correct rendering on high dpi screens\n\n\n    var correction = this.isEdgeBrowser ? 1 : 0;\n    var nodeHorizontalOffset = parseInt(node.scrollLeft + node.clientWidth, 10) - correction;\n    var nodeVerticalOffset = parseInt(node.scrollTop + node.clientHeight, 10) - correction;\n\n    if (node.scrollTop < 0 || node.scrollLeft < 0 || nodeHorizontalOffset > Math.max(node.scrollWidth, node.clientWidth) || nodeVerticalOffset > Math.max(node.scrollHeight, node.clientHeight)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  VirtualTableLayout.prototype.updateViewport = function (e) {\n    var node = e.target;\n\n    if (this.shouldSkipScrollEvent(e)) {\n      return;\n    }\n\n    this.setState({\n      viewportTop: node.scrollTop,\n      viewportLeft: node.scrollLeft\n    });\n  };\n\n  VirtualTableLayout.prototype.handleContainerSizeChange = function (_a) {\n    var width = _a.width,\n        height = _a.height;\n    this.setState({\n      width: width,\n      height: height\n    });\n  };\n\n  VirtualTableLayout.prototype.renderRowsBlock = function (name, collapsedGrid, Table, Body, blockRef, marginBottom) {\n    var _this = this;\n\n    var minWidth = this.props.minWidth;\n    var Row = this.props.rowComponent;\n    var Cell = this.props.cellComponent;\n    var tableRef = blockRef || createRef();\n    return createElement(RefHolder, {\n      ref: function ref(_ref) {\n        return _this.registerBlockRef(name, _ref);\n      }\n    }, createElement(Table, {\n      tableRef: tableRef,\n      style: _assign({\n        minWidth: minWidth + \"px\"\n      }, marginBottom ? {\n        marginBottom: marginBottom + \"px\"\n      } : null)\n    }, createElement(ColumnGroup, {\n      columns: collapsedGrid.columns\n    }), createElement(Body, null, collapsedGrid.rows.map(function (visibleRow) {\n      var row = visibleRow.row,\n          _a = visibleRow.cells,\n          cells = _a === void 0 ? [] : _a;\n      return createElement(RefHolder, {\n        key: row.key,\n        ref: function ref(_ref2) {\n          return _this.registerRowRef(row, _ref2);\n        }\n      }, createElement(Row, {\n        tableRow: row,\n        style: row.height !== undefined ? {\n          height: row.height + \"px\"\n        } : undefined\n      }, cells.map(function (cell) {\n        var column = cell.column;\n        return createElement(Cell, {\n          key: column.key,\n          tableRow: row,\n          tableColumn: column,\n          style: column.animationState,\n          colSpan: cell.colSpan\n        });\n      })));\n    }))));\n  };\n\n  VirtualTableLayout.prototype.render = function () {\n    var _a = this.props,\n        headerRows = _a.headerRows,\n        bodyRows = _a.bodyRows,\n        footerRows = _a.footerRows,\n        columns = _a.columns,\n        minColumnWidth = _a.minColumnWidth,\n        propHeight = _a.height,\n        Container = _a.containerComponent,\n        HeadTable = _a.headTableComponent,\n        FootTable = _a.footerTableComponent,\n        Table = _a.tableComponent,\n        Head = _a.headComponent,\n        Body = _a.bodyComponent,\n        Footer = _a.footerComponent,\n        getCellColSpan = _a.getCellColSpan,\n        tableRef = _a.tableRef;\n    var _b = this.state,\n        viewportLeft = _b.viewportLeft,\n        viewportTop = _b.viewportTop,\n        headerHeight = _b.headerHeight,\n        bodyHeight = _b.bodyHeight,\n        footerHeight = _b.footerHeight,\n        width = _b.width,\n        height = _b.height;\n    var getColumnWidth = this.getColumnWidthGetter(columns, width, minColumnWidth);\n\n    var getColSpan = function getColSpan(tableRow, tableColumn) {\n      return getCellColSpan({\n        tableRow: tableRow,\n        tableColumn: tableColumn,\n        tableColumns: columns\n      });\n    };\n    /* tslint:disable object-shorthand-properties-first */\n\n\n    var collapsedHeaderGrid = getCollapsedGrid({\n      rows: headerRows,\n      columns: columns,\n      top: 0,\n      left: viewportLeft,\n      width: width,\n      height: headerHeight,\n      getColumnWidth: getColumnWidth,\n      getRowHeight: this.getRowHeight,\n      getColSpan: getColSpan\n    });\n    var collapsedBodyGrid = getCollapsedGrid({\n      rows: bodyRows,\n      columns: columns,\n      top: viewportTop,\n      left: viewportLeft,\n      width: width,\n      height: height - headerHeight - footerHeight,\n      getColumnWidth: getColumnWidth,\n      getRowHeight: this.getRowHeight,\n      getColSpan: getColSpan\n    });\n    var collapsedFooterGrid = getCollapsedGrid({\n      rows: footerRows,\n      columns: columns,\n      top: 0,\n      left: viewportLeft,\n      width: width,\n      height: footerHeight,\n      getColumnWidth: getColumnWidth,\n      getRowHeight: this.getRowHeight,\n      getColSpan: getColSpan\n    });\n    /* tslint:enable object-shorthand-properties-first */\n\n    /* tslint:disable max-line-length */\n\n    return createElement(Sizer, {\n      onSizeChange: this.handleContainerSizeChange,\n      containerComponent: Container,\n      style: _assign({}, propHeight === AUTO_HEIGHT ? null : {\n        height: propHeight + \"px\"\n      }),\n      onScroll: this.updateViewport\n    }, !!headerRows.length && this.renderRowsBlock('header', collapsedHeaderGrid, HeadTable, Head), this.renderRowsBlock('body', collapsedBodyGrid, Table, Body, tableRef, Math.max(0, height - headerHeight - bodyHeight - footerHeight)), !!footerRows.length && this.renderRowsBlock('footer', collapsedFooterGrid, FootTable, Footer));\n    /* tslint:enable max-line-length */\n  };\n\n  VirtualTableLayout.defaultProps = defaultProps$3;\n  return VirtualTableLayout;\n}(PureComponent);\n\nvar getColumnStyle = function getColumnStyle(_a) {\n  var column = _a.column;\n  return column.animationState;\n};\n\nvar getRowStyle = function getRowStyle(_a) {\n  var row = _a.row;\n  return row.height !== undefined ? {\n    height: row.height + \"px\"\n  } : undefined;\n};\n/** @internal */\n\n\nvar RowLayout =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RowLayout, _super);\n\n  function RowLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RowLayout.prototype.render = function () {\n    var _a = this.props,\n        row = _a.row,\n        columns = _a.columns,\n        Row = _a.rowComponent,\n        Cell = _a.cellComponent,\n        getCellColSpan = _a.getCellColSpan;\n\n    var getColSpan = function getColSpan(tableRow, tableColumn) {\n      return getCellColSpan({\n        tableRow: tableRow,\n        tableColumn: tableColumn,\n        tableColumns: columns\n      });\n    };\n\n    return createElement(Row, {\n      tableRow: row,\n      style: getRowStyle({\n        row: row\n      })\n    }, columns.map(function (column) {\n      return createElement(Cell, {\n        key: column.key,\n        tableRow: row,\n        tableColumn: column,\n        style: getColumnStyle({\n          column: column\n        }),\n        colSpan: getColSpan(row, column)\n      });\n    }));\n  };\n\n  return RowLayout;\n}(PureComponent);\n/** @internal */\n\n\nvar RowsBlockLayout =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RowsBlockLayout, _super);\n\n  function RowsBlockLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RowsBlockLayout.prototype.render = function () {\n    var _a = this.props,\n        rows = _a.rows,\n        columns = _a.columns,\n        Block = _a.blockComponent,\n        rowComponent = _a.rowComponent,\n        cellComponent = _a.cellComponent,\n        getCellColSpan = _a.getCellColSpan;\n    return createElement(Block, null, rows.map(function (row) {\n      return createElement(RowLayout, {\n        key: row.key,\n        row: row,\n        columns: columns,\n        rowComponent: rowComponent,\n        cellComponent: cellComponent,\n        getCellColSpan: getCellColSpan\n      });\n    }));\n  };\n\n  return RowsBlockLayout;\n}(PureComponent);\n\nvar defaultProps$4 = {\n  headerRows: [],\n  footerRows: [],\n  headComponent: function headComponent() {\n    return null;\n  },\n  footerComponent: function footerComponent() {\n    return null;\n  }\n};\n/** @internal */\n\nvar StaticTableLayout =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(StaticTableLayout, _super);\n\n  function StaticTableLayout() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StaticTableLayout.prototype.render = function () {\n    var _a = this.props,\n        headerRows = _a.headerRows,\n        bodyRows = _a.bodyRows,\n        footerRows = _a.footerRows,\n        columns = _a.columns,\n        minWidth = _a.minWidth,\n        Container = _a.containerComponent,\n        Table = _a.tableComponent,\n        headComponent = _a.headComponent,\n        bodyComponent = _a.bodyComponent,\n        footerComponent = _a.footerComponent,\n        rowComponent = _a.rowComponent,\n        cellComponent = _a.cellComponent,\n        getCellColSpan = _a.getCellColSpan,\n        tableRef = _a.tableRef;\n    return createElement(Container, null, createElement(Table, {\n      tableRef: tableRef,\n      style: {\n        minWidth: minWidth + \"px\"\n      }\n    }, createElement(ColumnGroup, {\n      columns: columns\n    }), !!headerRows.length && createElement(RowsBlockLayout, {\n      rows: headerRows,\n      columns: columns,\n      blockComponent: headComponent,\n      rowComponent: rowComponent,\n      cellComponent: cellComponent,\n      getCellColSpan: getCellColSpan\n    }), createElement(RowsBlockLayout, {\n      rows: bodyRows,\n      columns: columns,\n      blockComponent: bodyComponent,\n      rowComponent: rowComponent,\n      cellComponent: cellComponent,\n      getCellColSpan: getCellColSpan\n    }), !!footerRows.length && createElement(RowsBlockLayout, {\n      rows: footerRows,\n      columns: columns,\n      blockComponent: footerComponent,\n      rowComponent: rowComponent,\n      cellComponent: cellComponent,\n      getCellColSpan: getCellColSpan\n    })));\n  };\n\n  StaticTableLayout.defaultProps = defaultProps$4;\n  return StaticTableLayout;\n}(PureComponent);\n/** @internal */\n\n\nvar makeVirtualTable = function makeVirtualTable(Table, _a) {\n  var VirtualLayout = _a.VirtualLayout,\n      FixedHeader = _a.FixedHeader,\n      FixedFooter = _a.FixedFooter,\n      defaultEstimatedRowHeight = _a.defaultEstimatedRowHeight,\n      defaultHeight = _a.defaultHeight;\n\n  var VirtualTable =\n  /*#__PURE__*/\n  function (_super) {\n    __extends(VirtualTable, _super);\n\n    function VirtualTable(props) {\n      var _this = _super.call(this, props) || this;\n\n      _this.layoutRenderComponent = connectProps(VirtualLayout, function () {\n        var _a = _this.props,\n            height = _a.height,\n            estimatedRowHeight = _a.estimatedRowHeight,\n            headTableComponent = _a.headTableComponent,\n            footerTableComponent = _a.footerTableComponent;\n        return {\n          height: height,\n          estimatedRowHeight: estimatedRowHeight,\n          headTableComponent: headTableComponent,\n          footerTableComponent: footerTableComponent\n        };\n      });\n      return _this;\n    }\n\n    VirtualTable.prototype.componentDidUpdate = function () {\n      this.layoutRenderComponent.update();\n    };\n\n    VirtualTable.prototype.render = function () {\n      var _a = this.props,\n          height = _a.height,\n          estimatedRowHeight = _a.estimatedRowHeight,\n          headTableComponent = _a.headTableComponent,\n          restProps = __rest(_a, [\"height\", \"estimatedRowHeight\", \"headTableComponent\"]);\n\n      return createElement(Table, _assign({\n        layoutComponent: this.layoutRenderComponent\n      }, restProps));\n    };\n\n    VirtualTable.defaultProps = {\n      estimatedRowHeight: defaultEstimatedRowHeight,\n      height: defaultHeight,\n      headTableComponent: FixedHeader,\n      footerTableComponent: FixedFooter\n    };\n    return VirtualTable;\n  }(PureComponent);\n\n  Object.values(Table.components).forEach(function (name) {\n    VirtualTable[name] = Table[name];\n  });\n  VirtualTable.FixedHeader = FixedHeader;\n  VirtualTable.FixedFooter = FixedFooter;\n  return VirtualTable;\n};\n\nexport { Grid, ColumnChooser, FilteringState, IntegratedFiltering, EditingState, PagingState, IntegratedPaging, CustomPaging, GroupingState, IntegratedGrouping, CustomGrouping, SelectionState, IntegratedSelection, SortingState, IntegratedSorting, DragDropProvider, TableColumnReordering, Table, TableSelection, RowDetailState, TableRowDetail, TableGroupRow, TableHeaderRow, TableBandHeader, TableFilterRow, TableEditRow, TableEditColumn, TableColumnResizing, PagingPanel, GroupingPanel, DataTypeProvider, TableColumnVisibility, Toolbar, TreeDataState, CustomTreeData, TableTreeColumn, SearchState, SearchPanel, TableFixedColumns, SummaryState, IntegratedSummary, CustomSummary, TableSummaryRow, TableLayout, VirtualTableLayout, StaticTableLayout, GroupPanelLayout, makeVirtualTable };","map":null,"metadata":{},"sourceType":"module"}