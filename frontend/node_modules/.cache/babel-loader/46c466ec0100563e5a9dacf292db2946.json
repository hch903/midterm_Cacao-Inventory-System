{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-react-core\n * Generated: 2019-03-28\n * Version: 1.10.5\n * License: https://js.devexpress.com/Licensing\n */\nimport { createContext, createElement, Children, PureComponent, Component, createRef } from 'react';\nimport { shallowEqual, PluginHost as PluginHost$1, EventEmitter } from '@devexpress/dx-core';\nimport { findDOMNode, unstable_batchedUpdates } from 'react-dom';\nimport { shape, instanceOf } from 'prop-types';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n/** @internal */\n\n\nvar PluginHostContext = createContext(null);\n/** @internal */\n\nvar PositionContext = createContext(function () {\n  return [];\n});\n/** @internal */\n\nvar TemplateHostContext = createContext(null);\n/** @internal */\n\nvar PluginIndexer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PluginIndexer, _super);\n\n  function PluginIndexer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.indexes = {};\n\n    _this.memoize = function (index, positionContext) {\n      if (_this.indexes[index]) return _this.indexes[index];\n\n      var fn = function fn() {\n        var calculatedPosition = positionContext();\n        return calculatedPosition.concat([index]);\n      };\n\n      _this.indexes[index] = fn;\n      return fn;\n    };\n\n    return _this;\n  }\n\n  PluginIndexer.prototype.render = function () {\n    var _this = this;\n\n    var children = this.props.children;\n    return createElement(PositionContext.Consumer, null, function (positionContext) {\n      return Children.map(children, function (child, index) {\n        if (!child || !child.type) return child;\n\n        var childPosition = _this.memoize(index, positionContext);\n\n        return createElement(PositionContext.Provider, {\n          value: childPosition\n        }, child);\n      });\n    });\n  };\n\n  return PluginIndexer;\n}(PureComponent);\n/** @internal */\n\n\nvar PLUGIN_HOST_CONTEXT = 'dxcore_pluginHost_context';\n/** @internal */\n\nvar POSITION_CONTEXT = 'dxcore_position_context';\n/** @internal */\n\nvar TEMPLATE_HOST_CONTEXT = 'dxcore_templateHost_context';\n/** @internal */\n\nvar RERENDER_TEMPLATE_EVENT = Symbol('rerenderTemplate');\n/** @internal */\n\nvar RERENDER_TEMPLATE_SCOPE_EVENT = Symbol('rerenderTemplateScope');\n/** @internal */\n\nvar UPDATE_CONNECTION_EVENT = Symbol('updateConnection');\n/** @internal */\n\nvar withContext = function withContext(Context, name) {\n  return function (Component) {\n    return function (props) {\n      return createElement(Context.Consumer, null, function (context) {\n        var _a;\n\n        return createElement(Component, _assign({}, props, (_a = {}, _a[name] = context, _a)));\n      });\n    };\n  };\n};\n/** @internal */\n\n\nvar withHostAndPosition = function withHostAndPosition(Component) {\n  return withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(PositionContext, POSITION_CONTEXT)(Component));\n};\n/** @internal */\n\n\nvar PluginBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PluginBase, _super);\n\n  function PluginBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PluginBase.prototype.componentDidMount = function () {\n    var _a = this.props,\n        _b = PLUGIN_HOST_CONTEXT,\n        pluginHost = _a[_b],\n        _c = POSITION_CONTEXT,\n        position = _a[_c];\n    var _d = this.props,\n        name = _d.name,\n        dependencies = _d.dependencies;\n    this.plugin = {\n      position: position,\n      name: name,\n      dependencies: dependencies,\n      container: true\n    };\n    pluginHost.registerPlugin(this.plugin);\n  };\n\n  PluginBase.prototype.componentDidUpdate = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.ensureDependencies();\n  };\n\n  PluginBase.prototype.componentWillUnmount = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.unregisterPlugin(this.plugin);\n  };\n\n  PluginBase.prototype.render = function () {\n    var children = this.props.children;\n    return createElement(PluginIndexer, null, children);\n  };\n\n  return PluginBase;\n}(PureComponent);\n\nvar Plugin = withHostAndPosition(PluginBase);\n\nvar TemplatePlaceholderBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TemplatePlaceholderBase, _super);\n\n  function TemplatePlaceholderBase(props) {\n    var _a;\n\n    var _this = _super.call(this, props) || this;\n\n    _this.template = null;\n    _this.params = {};\n    _this.restTemplates = [];\n    var propsName = _this.props.name;\n    _this.subscription = (_a = {}, _a[RERENDER_TEMPLATE_EVENT] = function (id) {\n      if (_this.template && _this.template.id === id) {\n        _this.forceUpdate();\n      }\n    }, _a[RERENDER_TEMPLATE_SCOPE_EVENT] = function (name) {\n      if (propsName === name) {\n        _this.forceUpdate();\n      }\n    }, _a);\n    return _this;\n  }\n\n  TemplatePlaceholderBase.prototype.componentDidMount = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.registerSubscription(this.subscription);\n  };\n\n  TemplatePlaceholderBase.prototype.shouldComponentUpdate = function (nextProps) {\n    var params = this.getRenderingData(nextProps).params;\n    var children = this.props.children;\n    return !shallowEqual(params, this.params) || children !== nextProps.children;\n  };\n\n  TemplatePlaceholderBase.prototype.componentWillUnmount = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.unregisterSubscription(this.subscription);\n  };\n\n  TemplatePlaceholderBase.prototype.getRenderingData = function (props) {\n    var name = props.name,\n        params = props.params;\n\n    if (name) {\n      var _a = PLUGIN_HOST_CONTEXT,\n          pluginHost = this.props[_a];\n      return {\n        params: params,\n        templates: pluginHost.collect(name + \"Template\").filter(function (template) {\n          return template.predicate(params);\n        }).reverse()\n      };\n    }\n\n    var _b = TEMPLATE_HOST_CONTEXT,\n        templateHost = this.props[_b];\n    return {\n      params: params || templateHost.params(),\n      templates: templateHost.templates()\n    };\n  };\n\n  TemplatePlaceholderBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.getRenderingData(this.props),\n        params = _a.params,\n        templates = _a.templates;\n\n    this.params = params;\n    this.template = templates[0];\n    this.restTemplates = templates.slice(1);\n    var content = null;\n\n    if (this.template) {\n      var templateContent = this.template.children;\n      content = templateContent() || null;\n\n      if (content && typeof content === 'function') {\n        content = content(params);\n      }\n    }\n\n    var templatePlaceholder = this.props.children;\n    return createElement(TemplateHostContext.Provider, {\n      value: {\n        templates: function templates() {\n          return _this.restTemplates;\n        },\n        params: function params() {\n          return _this.params;\n        }\n      }\n    }, templatePlaceholder ? templatePlaceholder(content) : content);\n  };\n\n  return TemplatePlaceholderBase;\n}(Component);\n/** A React component to which a related Template is rendered. */\n\n\nvar TemplatePlaceholder = withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(TemplateHostContext, TEMPLATE_HOST_CONTEXT)(TemplatePlaceholderBase));\n/** @internal */\n\nvar PluginHostBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(PluginHostBase, _super);\n\n  function PluginHostBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.host = new PluginHost$1();\n    return _this;\n  }\n\n  PluginHostBase.prototype.render = function () {\n    var children = this.props.children;\n    return createElement(PluginHostContext.Provider, {\n      value: this.host\n    }, createElement(PluginIndexer, null, children), createElement(TemplatePlaceholder, {\n      name: \"root\"\n    }));\n  };\n\n  return PluginHostBase;\n}(PureComponent);\n\nvar PluginHost = PluginHostBase;\n/** @internal */\n\nvar getAvailableGetters = function getAvailableGetters(pluginHost, getGetterValue) {\n  if (getGetterValue === void 0) {\n    getGetterValue = function getGetterValue(getterName) {\n      return pluginHost.get(getterName + \"Getter\");\n    };\n  }\n\n  var trackedDependencies = {};\n  var getters;\n\n  if (typeof Proxy !== 'undefined') {\n    getters = new Proxy({}, {\n      get: function get(target, prop) {\n        if (typeof prop !== 'string') return undefined;\n        var result = getGetterValue(prop);\n        trackedDependencies[prop] = result;\n        return result;\n      },\n      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {\n        return {\n          configurable: true,\n          enumerable: true,\n          value: this.get(target, prop, undefined)\n        };\n      },\n      ownKeys: function ownKeys() {\n        return pluginHost.knownKeys('Getter');\n      }\n    });\n  } else {\n    getters = pluginHost.knownKeys('Getter').reduce(function (acc, getterName) {\n      Object.defineProperty(acc, getterName, {\n        get: function get() {\n          var result = getGetterValue(getterName);\n          trackedDependencies[getterName] = result;\n          return result;\n        }\n      });\n      return acc;\n    }, {});\n  }\n\n  return {\n    getters: getters,\n    trackedDependencies: trackedDependencies\n  };\n};\n/** @internal */\n\n\nvar isTrackedDependenciesChanged = function isTrackedDependenciesChanged(pluginHost, prevTrackedDependencies, getGetterValue) {\n  if (getGetterValue === void 0) {\n    getGetterValue = function getGetterValue(getterName) {\n      return pluginHost.get(getterName + \"Getter\");\n    };\n  }\n\n  var trackedDependencies = Object.keys(prevTrackedDependencies) // tslint:disable-next-line: prefer-object-spread\n  .reduce(function (acc, getterName) {\n    var _a;\n\n    return Object.assign(acc, (_a = {}, _a[getterName] = getGetterValue(getterName), _a));\n  }, {});\n  return !shallowEqual(prevTrackedDependencies, trackedDependencies);\n};\n/** @internal */\n\n\nvar getAvailableActions = function getAvailableActions(pluginHost, getAction) {\n  if (getAction === void 0) {\n    getAction = function getAction(actionName) {\n      return pluginHost.collect(actionName + \"Action\").slice().reverse()[0];\n    };\n  }\n\n  var actions;\n\n  if (typeof Proxy !== 'undefined') {\n    actions = new Proxy({}, {\n      get: function get(target, prop) {\n        if (typeof prop !== 'string') return undefined;\n        return getAction(prop);\n      },\n      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {\n        return {\n          configurable: true,\n          enumerable: true,\n          value: this.get(target, prop, undefined)\n        };\n      },\n      ownKeys: function ownKeys() {\n        return pluginHost.knownKeys('Action');\n      }\n    });\n  } else {\n    actions = pluginHost.knownKeys('Action').reduce(function (acc, actionName) {\n      Object.defineProperty(acc, actionName, {\n        get: function get() {\n          return getAction(actionName);\n        }\n      });\n      return acc;\n    }, {});\n  }\n\n  return actions;\n};\n\nvar ActionBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ActionBase, _super);\n\n  function ActionBase(props) {\n    var _a;\n\n    var _this = _super.call(this, props) || this;\n\n    var _b = PLUGIN_HOST_CONTEXT,\n        pluginHost = props[_b],\n        _c = POSITION_CONTEXT,\n        positionContext = props[_c];\n    var name = props.name;\n    _this.plugin = (_a = {\n      position: function position() {\n        return positionContext();\n      }\n    }, _a[name + \"Action\"] = function (params) {\n      var action = _this.props.action;\n      var getters = getAvailableGetters(pluginHost, function (getterName) {\n        return pluginHost.get(getterName + \"Getter\", _this.plugin);\n      }).getters;\n      var nextParams = params;\n      var actions = getAvailableActions(pluginHost, function (actionName) {\n        return actionName === name ? function (newParams) {\n          nextParams = newParams;\n        } : pluginHost.collect(actionName + \"Action\", _this.plugin).slice().reverse()[0];\n      });\n      action(params, getters, actions);\n      var nextAction = pluginHost.collect(name + \"Action\", _this.plugin).slice().reverse()[0];\n\n      if (nextAction) {\n        nextAction(nextParams);\n      }\n    }, _a);\n    pluginHost.registerPlugin(_this.plugin);\n    return _this;\n  }\n\n  ActionBase.prototype.componentWillUnmount = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.unregisterPlugin(this.plugin);\n  };\n\n  ActionBase.prototype.render = function () {\n    return null;\n  };\n\n  return ActionBase;\n}(PureComponent);\n\nvar Action = withHostAndPosition(ActionBase);\n\nvar GetterBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(GetterBase, _super);\n\n  function GetterBase(props) {\n    var _a;\n\n    var _this = _super.call(this, props) || this;\n\n    var _b = PLUGIN_HOST_CONTEXT,\n        pluginHost = props[_b],\n        _c = POSITION_CONTEXT,\n        positionContext = props[_c];\n    var name = props.name;\n    var lastComputed;\n    var lastTrackedDependencies = {};\n    var lastResult;\n    _this.plugin = (_a = {\n      position: function position() {\n        return positionContext();\n      }\n    }, _a[name + \"Getter\"] = function (original) {\n      var _a = _this.props,\n          value = _a.value,\n          computed = _a.computed;\n      if (computed === undefined) return value;\n\n      var getGetterValue = function getGetterValue(getterName) {\n        return getterName === name ? original : pluginHost.get(getterName + \"Getter\", _this.plugin);\n      };\n\n      if (computed === lastComputed && !isTrackedDependenciesChanged(pluginHost, lastTrackedDependencies, getGetterValue)) {\n        return lastResult;\n      }\n\n      var _b = getAvailableGetters(pluginHost, getGetterValue),\n          getters = _b.getters,\n          trackedDependencies = _b.trackedDependencies;\n\n      var actions = getAvailableActions(pluginHost);\n      lastComputed = computed;\n      lastTrackedDependencies = trackedDependencies;\n      lastResult = computed(getters, actions);\n      return lastResult;\n    }, _a);\n    pluginHost.registerPlugin(_this.plugin);\n    return _this;\n  }\n\n  GetterBase.prototype.componentDidUpdate = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.broadcast(UPDATE_CONNECTION_EVENT);\n  };\n\n  GetterBase.prototype.componentWillUnmount = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.unregisterPlugin(this.plugin);\n  };\n\n  GetterBase.prototype.render = function () {\n    return null;\n  };\n\n  return GetterBase;\n}(PureComponent);\n\nvar Getter = withHostAndPosition(GetterBase);\nvar globalTemplateId = 0;\n/** @internal */\n\nvar TemplateBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TemplateBase, _super);\n\n  function TemplateBase(props) {\n    var _a;\n\n    var _this = _super.call(this, props) || this;\n\n    _this.children = function () {\n      return void 0;\n    };\n\n    globalTemplateId += 1;\n    _this.id = globalTemplateId;\n    var _b = PLUGIN_HOST_CONTEXT,\n        pluginHost = props[_b],\n        _c = POSITION_CONTEXT,\n        positionContext = props[_c];\n    var name = props.name,\n        _predicate = props.predicate;\n    _this.plugin = (_a = {\n      position: function position() {\n        return positionContext();\n      }\n    }, _a[name + \"Template\"] = {\n      id: _this.id,\n      predicate: function predicate(params) {\n        return _predicate ? _predicate(params) : true;\n      },\n      children: function children() {\n        var children = _this.props.children;\n        return children;\n      }\n    }, _a);\n    pluginHost.registerPlugin(_this.plugin);\n    pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);\n    return _this;\n  }\n\n  TemplateBase.prototype.componentDidUpdate = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    pluginHost.broadcast(RERENDER_TEMPLATE_EVENT, this.id);\n  };\n\n  TemplateBase.prototype.componentWillUnmount = function () {\n    var _a = PLUGIN_HOST_CONTEXT,\n        pluginHost = this.props[_a];\n    var name = this.props.name;\n    pluginHost.unregisterPlugin(this.plugin);\n    pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);\n  };\n\n  TemplateBase.prototype.render = function () {\n    return null;\n  };\n\n  return TemplateBase;\n}(PureComponent);\n/*** A React component that defines a markup that is rendered\r\n * as the corresponding TemplatePlaceholder.\r\n */\n\n\nvar Template = withHostAndPosition(TemplateBase);\n/** @internal */\n\nvar TemplateConnectorBase =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(TemplateConnectorBase, _super);\n\n  function TemplateConnectorBase(props, context) {\n    var _a;\n\n    var _this = _super.call(this, props, context) || this;\n\n    _this.trackedDependencies = {};\n    _this.subscription = (_a = {}, _a[UPDATE_CONNECTION_EVENT] = function () {\n      return _this.updateConnection();\n    }, _a);\n    return _this;\n  }\n\n  TemplateConnectorBase.prototype.componentDidMount = function () {\n    var pluginHost = this.context;\n    pluginHost.registerSubscription(this.subscription);\n  };\n\n  TemplateConnectorBase.prototype.componentWillUnmount = function () {\n    var pluginHost = this.context;\n    pluginHost.unregisterSubscription(this.subscription);\n  };\n\n  TemplateConnectorBase.prototype.updateConnection = function () {\n    var pluginHost = this.context;\n\n    if (isTrackedDependenciesChanged(pluginHost, this.trackedDependencies)) {\n      this.forceUpdate();\n    }\n  };\n\n  TemplateConnectorBase.prototype.render = function () {\n    var pluginHost = this.context;\n    var children = this.props.children;\n\n    var _a = getAvailableGetters(pluginHost),\n        getters = _a.getters,\n        trackedDependencies = _a.trackedDependencies;\n\n    this.trackedDependencies = trackedDependencies;\n    var actions = getAvailableActions(pluginHost);\n    return children(getters, actions);\n  };\n\n  return TemplateConnectorBase;\n}(Component);\n\nTemplateConnectorBase.contextType = PluginHostContext;\n/** A React component that provides access to Getters and Actions within a Template. */\n\nvar TemplateConnector = TemplateConnectorBase;\nvar TIMEOUT = 180;\n/** @internal */\n\nvar TouchStrategy =\n/*#__PURE__*/\nfunction () {\n  function TouchStrategy(delegate) {\n    this.delegate = delegate;\n    this.touchStartTimeout = null;\n    this.dragging = false;\n  }\n\n  TouchStrategy.prototype.isDragging = function () {\n    return this.dragging;\n  };\n\n  TouchStrategy.prototype.isWaiting = function () {\n    return !!this.touchStartTimeout;\n  };\n\n  TouchStrategy.prototype.cancelWaiting = function () {\n    clearTimeout(this.touchStartTimeout);\n    this.touchStartTimeout = undefined;\n  };\n\n  TouchStrategy.prototype.start = function (e) {\n    var _this = this;\n\n    var _a = e.touches[0],\n        x = _a.clientX,\n        y = _a.clientY;\n    this.touchStartTimeout = setTimeout(function () {\n      _this.delegate.onStart({\n        x: x,\n        y: y\n      });\n\n      _this.dragging = true;\n    }, TIMEOUT);\n  };\n\n  TouchStrategy.prototype.move = function (e) {\n    this.cancelWaiting();\n\n    if (this.dragging) {\n      var _a = e.touches[0],\n          clientX = _a.clientX,\n          clientY = _a.clientY;\n      e.preventDefault();\n      this.delegate.onMove({\n        x: clientX,\n        y: clientY\n      });\n    }\n  };\n\n  TouchStrategy.prototype.end = function (e) {\n    this.cancelWaiting();\n\n    if (this.dragging) {\n      var _a = e.changedTouches[0],\n          clientX = _a.clientX,\n          clientY = _a.clientY;\n      this.delegate.onEnd({\n        x: clientX,\n        y: clientY\n      });\n    }\n\n    this.mouseInitialOffset = null;\n    this.dragging = false;\n  };\n\n  return TouchStrategy;\n}();\n/* globals document:true */\n\n\nvar gestureCover;\n/** @internal */\n\nvar toggleGestureCover = function toggleGestureCover(toggle, cursor) {\n  var style = {\n    pointerEvents: toggle ? 'all' : 'none'\n  };\n\n  if (toggle && cursor) {\n    style = _assign({}, style, {\n      cursor: cursor\n    });\n  }\n\n  if (!gestureCover) {\n    style = _assign({}, style, {\n      position: 'fixed',\n      top: 0,\n      right: 0,\n      left: 0,\n      bottom: 0,\n      opacity: 0,\n      zIndex: 2147483647\n    });\n    gestureCover = document.createElement('div');\n    document.body.appendChild(gestureCover);\n  }\n\n  Object.keys(style).forEach(function (key) {\n    gestureCover.style[key] = style[key];\n  });\n};\n/* globals window:true document:true */\n\n\nvar BOUNDARY = 10;\n\nvar clamp = function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar isBoundExceeded = function isBoundExceeded(_a, _b) {\n  var initialX = _a.x,\n      initialY = _a.y;\n  var x = _b.x,\n      y = _b.y;\n  return clamp(x, initialX - BOUNDARY, initialX + BOUNDARY) !== x || clamp(y, initialY - BOUNDARY, initialY + BOUNDARY) !== y;\n};\n/** @internal */\n\n\nvar MouseStrategy =\n/*#__PURE__*/\nfunction () {\n  function MouseStrategy(delegate) {\n    this.delegate = delegate;\n    this.mouseInitialOffset = null;\n    this.dragging = false;\n  }\n\n  MouseStrategy.prototype.isDragging = function () {\n    return this.dragging;\n  };\n\n  MouseStrategy.prototype.start = function (e) {\n    var x = e.clientX,\n        y = e.clientY;\n    this.e = e;\n    this.mouseInitialOffset = {\n      x: x,\n      y: y\n    };\n  };\n\n  MouseStrategy.prototype.move = function (e) {\n    var x = e.clientX,\n        y = e.clientY;\n    var dragStarted = false;\n\n    if (!this.dragging && this.mouseInitialOffset) {\n      if (isBoundExceeded(this.mouseInitialOffset, {\n        x: x,\n        y: y\n      })) {\n        this.delegate.onStart(this.mouseInitialOffset);\n\n        if (window.getSelection) {\n          window.getSelection().removeAllRanges();\n        }\n\n        dragStarted = true;\n        this.dragging = true;\n      }\n    }\n\n    if (this.dragging) {\n      e.preventDefault();\n      this.delegate.onMove({\n        x: x,\n        y: y\n      });\n    }\n\n    if (dragStarted) {\n      var cursor = window.getComputedStyle(document.elementFromPoint(x, y)).cursor;\n      toggleGestureCover(true, cursor);\n    }\n  };\n\n  MouseStrategy.prototype.end = function (e) {\n    if (this.dragging) {\n      var x = e.clientX,\n          y = e.clientY;\n      toggleGestureCover(false);\n      this.delegate.onEnd({\n        x: x,\n        y: y\n      });\n    }\n\n    this.mouseInitialOffset = null;\n    this.dragging = false;\n  };\n\n  return MouseStrategy;\n}();\n/* globals window:true */\n\n\nvar eventEmitter;\n/** @internal */\n\nvar getSharedEventEmitter = function getSharedEventEmitter() {\n  if (!eventEmitter) {\n    eventEmitter = new EventEmitter();\n    ['mousemove', 'mouseup', 'touchmove', 'touchend', 'touchcancel'].forEach(function (name) {\n      return window.addEventListener(name, function (e) {\n        return eventEmitter.emit([name, e]);\n      }, {\n        passive: false\n      });\n    });\n  }\n\n  return eventEmitter;\n};\n/* globals document:true window:true */\n\n/** @internal */\n\n\nvar clear = function clear() {\n  if (window.getSelection) {\n    if (window.getSelection().empty) {\n      window.getSelection().empty();\n    } else if (window.getSelection().removeAllRanges) {\n      window.getSelection().removeAllRanges();\n    }\n  }\n};\n\nvar draggingHandled = Symbol('draggingHandled');\n/** @internal */\n\nvar Draggable =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Draggable, _super);\n\n  function Draggable(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    var delegate = {\n      onStart: function onStart(_a) {\n        var x = _a.x,\n            y = _a.y;\n        var onStart = _this.props.onStart;\n        if (!onStart) return;\n        unstable_batchedUpdates(function () {\n          onStart({\n            x: x,\n            y: y\n          });\n        });\n      },\n      onMove: function onMove(_a) {\n        var x = _a.x,\n            y = _a.y;\n        var onUpdate = _this.props.onUpdate;\n        if (!onUpdate) return;\n        unstable_batchedUpdates(function () {\n          onUpdate({\n            x: x,\n            y: y\n          });\n        });\n      },\n      onEnd: function onEnd(_a) {\n        var x = _a.x,\n            y = _a.y;\n        var onEnd = _this.props.onEnd;\n        if (!onEnd) return;\n        unstable_batchedUpdates(function () {\n          onEnd({\n            x: x,\n            y: y\n          });\n        });\n      }\n    };\n    _this.mouseStrategy = new MouseStrategy(delegate);\n    _this.touchStrategy = new TouchStrategy(delegate);\n    _this.mouseDownListener = _this.mouseDownListener.bind(_this);\n    _this.touchStartListener = _this.touchStartListener.bind(_this);\n    _this.globalListener = _this.globalListener.bind(_this);\n    return _this;\n  }\n\n  Draggable.prototype.componentDidMount = function () {\n    getSharedEventEmitter().subscribe(this.globalListener);\n    this.setupNodeSubscription();\n  };\n\n  Draggable.prototype.shouldComponentUpdate = function (nextProps) {\n    var children = this.props.children;\n    return nextProps.children !== children;\n  };\n\n  Draggable.prototype.componentDidUpdate = function () {\n    this.setupNodeSubscription();\n  };\n\n  Draggable.prototype.componentWillUnmount = function () {\n    getSharedEventEmitter().unsubscribe(this.globalListener);\n  };\n\n  Draggable.prototype.setupNodeSubscription = function () {\n    var node = findDOMNode(this);\n    if (!node) return;\n    node.removeEventListener('mousedown', this.mouseDownListener);\n    node.removeEventListener('touchstart', this.touchStartListener);\n    node.addEventListener('mousedown', this.mouseDownListener, {\n      passive: true\n    });\n    node.addEventListener('touchstart', this.touchStartListener, {\n      passive: true\n    });\n  };\n\n  Draggable.prototype.mouseDownListener = function (e) {\n    if (this.touchStrategy.isWaiting() || e[draggingHandled]) return;\n    this.mouseStrategy.start(e);\n    e[draggingHandled] = true;\n  };\n\n  Draggable.prototype.touchStartListener = function (e) {\n    if (e[draggingHandled]) return;\n    this.touchStrategy.start(e);\n    e[draggingHandled] = true;\n  };\n\n  Draggable.prototype.globalListener = function (_a) {\n    var name = _a[0],\n        e = _a[1];\n\n    switch (name) {\n      case 'mousemove':\n        this.mouseStrategy.move(e);\n        break;\n\n      case 'mouseup':\n        this.mouseStrategy.end(e);\n        break;\n\n      case 'touchmove':\n        {\n          this.touchStrategy.move(e);\n          break;\n        }\n\n      case 'touchend':\n      case 'touchcancel':\n        {\n          this.touchStrategy.end(e);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    if (this.mouseStrategy.isDragging() || this.touchStrategy.isDragging()) {\n      clear();\n    }\n  };\n\n  Draggable.prototype.render = function () {\n    var children = this.props.children;\n    return children;\n  };\n\n  return Draggable;\n}(Component);\n/** @internal */\n\n\nvar DragDropContext = createContext(null);\n/** @internal */\n\nvar DragDropProviderCore =\n/*#__PURE__*/\nfunction () {\n  function DragDropProviderCore() {\n    this.payload = null;\n    this.dragEmitter = new EventEmitter();\n  }\n\n  DragDropProviderCore.prototype.start = function (payload, clientOffset) {\n    this.payload = payload;\n    this.dragEmitter.emit({\n      clientOffset: clientOffset,\n      payload: this.payload\n    });\n  };\n\n  DragDropProviderCore.prototype.update = function (clientOffset) {\n    this.dragEmitter.emit({\n      clientOffset: clientOffset,\n      payload: this.payload\n    });\n  };\n\n  DragDropProviderCore.prototype.end = function (clientOffset) {\n    this.dragEmitter.emit({\n      clientOffset: clientOffset,\n      payload: this.payload,\n      end: true\n    });\n    this.payload = null;\n  };\n\n  return DragDropProviderCore;\n}();\n\nvar defaultProps = {\n  onChange: function onChange(_a) {\n    var payload = _a.payload,\n        clientOffset = _a.clientOffset;\n  }\n};\n/** @internal */\n// tslint:disable-next-line: max-classes-per-file\n\nvar DragDropProvider =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DragDropProvider, _super);\n\n  function DragDropProvider(props) {\n    var _this = _super.call(this, props) || this;\n\n    var onChange = _this.props.onChange;\n    _this.dragDropProvider = new DragDropProviderCore();\n\n    _this.dragDropProvider.dragEmitter.subscribe(function (_a) {\n      var payload = _a.payload,\n          clientOffset = _a.clientOffset,\n          end = _a.end;\n      onChange({\n        payload: end ? null : payload,\n        clientOffset: end ? null : clientOffset\n      });\n    });\n\n    return _this;\n  }\n\n  DragDropProvider.prototype.shouldComponentUpdate = function (nextProps) {\n    var children = this.props.children;\n    return nextProps.children !== children;\n  };\n\n  DragDropProvider.prototype.render = function () {\n    var children = this.props.children;\n    return createElement(DragDropContext.Provider, {\n      value: this.dragDropProvider\n    }, children);\n  };\n\n  DragDropProvider.defaultProps = defaultProps;\n  return DragDropProvider;\n}(Component);\n\nvar defaultProps$1 = {\n  onStart: function onStart(_a) {\n    var clientOffset = _a.clientOffset;\n  },\n  onUpdate: function onUpdate(_a) {\n    var clientOffset = _a.clientOffset;\n  },\n  onEnd: function onEnd(_a) {\n    var clientOffset = _a.clientOffset;\n  }\n};\n/** @internal */\n\nvar DragSource =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DragSource, _super);\n\n  function DragSource() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DragSource.prototype.shouldComponentUpdate = function (nextProps) {\n    var children = this.props.children;\n    return nextProps.children !== children;\n  };\n\n  DragSource.prototype.render = function () {\n    var dragDropProvider = this.context;\n    var _a = this.props,\n        _onStart = _a.onStart,\n        _onUpdate = _a.onUpdate,\n        _onEnd = _a.onEnd,\n        payload = _a.payload,\n        children = _a.children;\n    return createElement(Draggable, {\n      onStart: function onStart(_a) {\n        var x = _a.x,\n            y = _a.y;\n        dragDropProvider.start(payload, {\n          x: x,\n          y: y\n        });\n\n        _onStart({\n          clientOffset: {\n            x: x,\n            y: y\n          }\n        });\n      },\n      onUpdate: function onUpdate(_a) {\n        var x = _a.x,\n            y = _a.y;\n        dragDropProvider.update({\n          x: x,\n          y: y\n        });\n\n        _onUpdate({\n          clientOffset: {\n            x: x,\n            y: y\n          }\n        });\n      },\n      onEnd: function onEnd(_a) {\n        var x = _a.x,\n            y = _a.y;\n        dragDropProvider.end({\n          x: x,\n          y: y\n        });\n\n        _onEnd({\n          clientOffset: {\n            x: x,\n            y: y\n          }\n        });\n      }\n    }, children);\n  };\n\n  DragSource.defaultProps = defaultProps$1;\n  return DragSource;\n}(Component);\n\nDragSource.contextType = DragDropContext;\n\nvar clamp$1 = function clamp$1(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar defaultProps$2 = {\n  onEnter: function onEnter(args) {},\n  onOver: function onOver(args) {},\n  onLeave: function onLeave(args) {},\n  onDrop: function onDrop(args) {}\n};\n/** @internal */\n\nvar DropTarget =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(DropTarget, _super);\n\n  function DropTarget(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.isOver = false;\n    _this.handleDrag = _this.handleDrag.bind(_this);\n    return _this;\n  }\n\n  DropTarget.prototype.componentDidMount = function () {\n    var dragEmitter = this.context.dragEmitter;\n    dragEmitter.subscribe(this.handleDrag);\n  };\n\n  DropTarget.prototype.shouldComponentUpdate = function (nextProps) {\n    var children = this.props.children;\n    return nextProps.children !== children;\n  };\n\n  DropTarget.prototype.componentWillUnmount = function () {\n    var dragEmitter = this.context.dragEmitter;\n    dragEmitter.unsubscribe(this.handleDrag);\n  };\n\n  DropTarget.prototype.handleDrag = function (_a) {\n    var payload = _a.payload,\n        clientOffset = _a.clientOffset,\n        end = _a.end;\n\n    var _b = findDOMNode(this).getBoundingClientRect(),\n        left = _b.left,\n        top = _b.top,\n        right = _b.right,\n        bottom = _b.bottom;\n\n    var _c = this.props,\n        onDrop = _c.onDrop,\n        onEnter = _c.onEnter,\n        onLeave = _c.onLeave,\n        onOver = _c.onOver;\n    var isOver = clientOffset && clamp$1(clientOffset.x, left, right) === clientOffset.x && clamp$1(clientOffset.y, top, bottom) === clientOffset.y;\n    if (!this.isOver && isOver) onEnter({\n      payload: payload,\n      clientOffset: clientOffset\n    });\n    if (this.isOver && isOver) onOver({\n      payload: payload,\n      clientOffset: clientOffset\n    });\n    if (this.isOver && !isOver) onLeave({\n      payload: payload,\n      clientOffset: clientOffset\n    });\n    if (isOver && end) onDrop({\n      payload: payload,\n      clientOffset: clientOffset\n    });\n    this.isOver = isOver && !end;\n  };\n\n  DropTarget.prototype.render = function () {\n    var children = this.props.children;\n    return Children.only(children);\n  };\n\n  DropTarget.defaultProps = defaultProps$2;\n  return DropTarget;\n}(Component);\n\nDropTarget.contextType = DragDropContext;\n/** @internal */\n\nvar RefHolder =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(RefHolder, _super);\n\n  function RefHolder() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  RefHolder.prototype.render = function () {\n    var children = this.props.children;\n    return children;\n  };\n\n  return RefHolder;\n}(PureComponent);\n/* globals document:true */\n\n\nvar styles = {\n  root: {\n    position: 'relative'\n  },\n  triggersRoot: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    overflow: 'hidden',\n    zIndex: -1,\n    visibility: 'hidden',\n    opacity: 0\n  },\n  expandTrigger: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    overflow: 'auto'\n  },\n  contractTrigger: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    overflow: 'auto',\n    minHeight: '1px',\n    minWidth: '1px'\n  },\n  contractNotifier: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '200%',\n    height: '200%'\n  }\n};\n/** @internal */\n\nvar Sizer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Sizer, _super);\n\n  function Sizer(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.setupListeners = _this.setupListeners.bind(_this);\n    _this.rootRef = createRef();\n    return _this;\n  }\n\n  Sizer.prototype.componentDidMount = function () {\n    this.createListeners();\n    this.setupListeners();\n  }; // There is no need to remove listeners as divs are removed from DOM when component is unmount.\n  // But there is a little chance that component unmounting and 'scroll' event happen roughly\n  // at the same time so that `setupListeners` is called after component is unmount.\n\n\n  Sizer.prototype.componentWillUnmount = function () {\n    this.expandTrigger.removeEventListener('scroll', this.setupListeners);\n    this.contractTrigger.removeEventListener('scroll', this.setupListeners);\n  };\n\n  Sizer.prototype.setupListeners = function () {\n    var size = {\n      height: this.rootNode.clientHeight,\n      width: this.rootNode.clientWidth\n    };\n    this.contractTrigger.scrollTop = size.height;\n    this.contractTrigger.scrollLeft = size.width;\n    var scrollOffset = 2;\n    this.expandNotifier.style.width = size.width + scrollOffset + \"px\";\n    this.expandNotifier.style.height = size.height + scrollOffset + \"px\";\n    this.expandTrigger.scrollTop = scrollOffset;\n    this.expandTrigger.scrollLeft = scrollOffset;\n    var onSizeChange = this.props.onSizeChange;\n    onSizeChange(size);\n  };\n\n  Sizer.prototype.createListeners = function () {\n    this.rootNode = findDOMNode(this.rootRef.current);\n    this.triggersRoot = document.createElement('div');\n    Object.assign(this.triggersRoot.style, styles.triggersRoot);\n    this.rootNode.appendChild(this.triggersRoot);\n    this.expandTrigger = document.createElement('div');\n    Object.assign(this.expandTrigger.style, styles.expandTrigger);\n    this.expandTrigger.addEventListener('scroll', this.setupListeners);\n    this.triggersRoot.appendChild(this.expandTrigger);\n    this.expandNotifier = document.createElement('div');\n    this.expandTrigger.appendChild(this.expandNotifier);\n    this.contractTrigger = document.createElement('div');\n    Object.assign(this.contractTrigger.style, styles.contractTrigger);\n    this.contractTrigger.addEventListener('scroll', this.setupListeners);\n    this.triggersRoot.appendChild(this.contractTrigger);\n    this.contractNotifier = document.createElement('div');\n    Object.assign(this.contractNotifier.style, styles.contractNotifier);\n    this.contractTrigger.appendChild(this.contractNotifier);\n  };\n\n  Sizer.prototype.render = function () {\n    var _a = this.props,\n        onSizeChange = _a.onSizeChange,\n        Container = _a.containerComponent,\n        style = _a.style,\n        restProps = __rest(_a, [\"onSizeChange\", \"containerComponent\", \"style\"]);\n\n    return createElement(RefHolder, {\n      ref: this.rootRef\n    }, createElement(Container // NOTE: should have `position: relative`\n    , _assign({\n      style: style ? _assign({}, styles.root, style) : styles.root\n    }, restProps)));\n  };\n\n  Sizer.defaultProps = {\n    containerComponent: 'div'\n  };\n  return Sizer;\n}(PureComponent);\n/*** A function that creates a new component that allows you to pass additional properties\r\n * to the wrapped component.\r\n */\n\n\nvar connectProps = function connectProps(WrappedComponent, getAdditionalProps) {\n  var storedAdditionalProps = getAdditionalProps();\n  var components = new Set();\n\n  var RenderComponent =\n  /*#__PURE__*/\n  function (_super) {\n    __extends(RenderComponent, _super);\n\n    function RenderComponent() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    RenderComponent.prototype.componentDidMount = function () {\n      components.add(this);\n    };\n\n    RenderComponent.prototype.componentWillUnmount = function () {\n      components.delete(this);\n    };\n\n    RenderComponent.prototype.render = function () {\n      return createElement(WrappedComponent, _assign({}, this.props, storedAdditionalProps));\n    };\n\n    return RenderComponent;\n  }(PureComponent);\n\n  RenderComponent.update = function () {\n    storedAdditionalProps = getAdditionalProps();\n    Array.from(components.values()).forEach(function (component) {\n      return component.forceUpdate();\n    });\n  };\n\n  return RenderComponent;\n};\n/** @internal */\n\n\nvar createStateHelper = function createStateHelper(component, controlledStateProperties) {\n  if (controlledStateProperties === void 0) {\n    controlledStateProperties = {};\n  }\n\n  var notifyStateChange = function notifyStateChange(nextState, state) {\n    Object.keys(controlledStateProperties).forEach(function (propertyName) {\n      var changeEvent = controlledStateProperties[propertyName]();\n\n      if (changeEvent && nextState[propertyName] !== state[propertyName]) {\n        changeEvent(nextState[propertyName]);\n      }\n    });\n  };\n\n  var lastStateUpdater;\n  var initialState = null;\n  var lastInitialState = null;\n\n  var applyReducer = function applyReducer(reduce, payload, callback) {\n    var stateUpdater = function stateUpdater(prevState) {\n      if (initialState === null) {\n        initialState = prevState;\n      }\n\n      var stateChange = reduce(_assign({}, prevState), payload);\n\n      var state = _assign({}, prevState, stateChange);\n\n      if (typeof callback === 'function') {\n        callback(state, prevState);\n      }\n\n      if (stateUpdater === lastStateUpdater) {\n        if (lastInitialState !== initialState) {\n          notifyStateChange(state, initialState);\n          lastInitialState = initialState;\n        }\n\n        initialState = null;\n      }\n\n      return stateChange;\n    };\n\n    lastStateUpdater = stateUpdater;\n    component.setState(stateUpdater);\n  };\n\n  var applyFieldReducer = function applyFieldReducer(field, reduce, payload) {\n    applyReducer(function (state) {\n      var _a;\n\n      return _a = {}, _a[field] = reduce(state[field], payload), _a;\n    });\n  };\n\n  return {\n    applyReducer: applyReducer,\n    applyFieldReducer: applyFieldReducer\n  };\n};\n\nvar makeBoundComponent = function makeBoundComponent(Target, components, exposed) {\n  var Component =\n  /*#__PURE__*/\n  function (_super) {\n    __extends(Component, _super);\n\n    function Component() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    Component.prototype.render = function () {\n      return createElement(Target, _assign({}, components, this.props));\n    };\n\n    return Component;\n  }(PureComponent);\n\n  Component.components = Target.components;\n  Object.assign(Component, exposed);\n  return Component;\n}; // type ITargetComponentStatic = new() => ITargetComponent;\n\n/** @internal */\n\n\nvar withComponents = function withComponents(components) {\n  return function (Target) {\n    var props = {};\n    var exposed = {};\n    var targetComponents = Target.components;\n    Object.entries(targetComponents).forEach(function (_a) {\n      var fieldName = _a[0],\n          componentName = _a[1];\n      var component = components[componentName];\n\n      if (component && component !== Target[componentName]) {\n        props[fieldName] = component;\n      }\n\n      exposed[componentName] = component || Target[componentName];\n    });\n    return Object.keys(props).length > 0 ? makeBoundComponent(Target, props, exposed) : Target;\n  };\n};\n/* globals Element */\n\n/** @internal */\n\n\nvar RefType = shape({\n  current: instanceOf(typeof Element !== 'undefined' ? Element : Object)\n});\nexport { Plugin, PluginHost, Action, Getter, Template, TemplatePlaceholder, TemplateConnector, Draggable, DragDropProvider, DragSource, DropTarget, Sizer, RefHolder, connectProps, createStateHelper, withComponents, RefType };","map":null,"metadata":{},"sourceType":"module"}